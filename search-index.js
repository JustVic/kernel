var searchIndex = {};
searchIndex["alloc"] = {"doc":"SOS memory allocation library","items":[[3,"Excess","alloc","Represents the combination of a starting address and a total capacity of the returned block.",null,null],[3,"Layout","","Category for a memory record.",null,null],[3,"CannotReallocInPlace","","The `CannotReallocInPlace` error is used when `fn realloc_in_place` was unable to reuse the given memory block for a requested layout.",null,null],[4,"AllocErr","","The `AllocErr` error specifies whether an allocation failure is specifically due to resource exhaustion or if it is due to something wrong when combining the given input arguments with this allocator.",null,null],[13,"Exhausted","","Error due to hitting some resource limit or otherwise running out of memory. This condition strongly implies that some series of deallocations would allow a subsequent reissuing of the original allocation request to succeed.",0,null],[12,"request","alloc::AllocErr","",0,null],[13,"Unsupported","alloc","Error due to allocator being fundamentally incapable of satisfying the original request. This condition implies that such an allocation request will never succeed on the given allocator, regardless of environment, memory pressure, or other contextual condtions.",0,null],[12,"details","alloc::AllocErr","",0,null],[0,"frame","alloc","Frame allocation",null,null],[3,"BorrowedFrame","alloc::frame","A borrowed handle on a frame with a specified lifetime.",null,null],[3,"BorrowedFrameRange","","Identical to a `BorrowedFrame` but borrowing a range of `Frame`s.",null,null],[0,"mem_map","","A simple allocator using the [`InitParams`] memory map.",null,null],[3,"MemMapAllocator","alloc::frame::mem_map","A simple area allocator.",null,null],[11,"from","","",1,{"inputs":[{"name":"initparams"}],"output":{"name":"self"}}],[11,"allocate","","",1,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[11,"deallocate","","Deallocate a frame",1,{"inputs":[{"name":"self"},{"name":"frame"}],"output":null}],[11,"allocate_range","","Allocate a range of frames",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[11,"deallocate_range","","Deallocate a range of frames",1,{"inputs":[{"name":"self"},{"name":"framerange"}],"output":null}],[8,"Allocator","alloc::frame","An allocator for allocating physical frames.",null,null],[10,"allocate","","Allocate a new frame",2,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[10,"deallocate","","Deallocate a frame",2,{"inputs":[{"name":"self"},{"name":"frame"}],"output":null}],[10,"allocate_range","","Allocate a range of frames",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[10,"deallocate_range","","Deallocate a range of frames",2,{"inputs":[{"name":"self"},{"name":"framerange"}],"output":null}],[8,"Lender","","An allocator capable of lending [borrowed frame]s",null,null],[10,"borrow","","Borrow a `Frame` from this allocator. e  The `BorrowedFrame` will live as long as this allocator, and will  contain a handle on a `Frame` that will be automatically deallocated  when the `BorrowedFrame` is dropped.",3,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[10,"borrow_range","","Borrow a `FrameRange` from this allocator.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[11,"deref","","",4,null],[11,"deref_mut","","",4,null],[11,"drop","","",4,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",5,null],[11,"deref_mut","","",5,null],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[0,"borrow","alloc","",null,null],[3,"BorrowedPtr","alloc::borrow","A borrowed handle on a heap allocation with a specified lifetime.",null,null],[3,"Borrowed","","A borrowed handle on a heap allocation with a specified lifetime.",null,null],[8,"Lender","","",null,null],[16,"Borrowed","","",6,null],[10,"borrow","","",6,null],[11,"new","","",7,{"inputs":[{"name":"address"},{"name":"layout"},{"name":"mutex"}],"output":{"name":"self"}}],[11,"deref","","",7,null],[11,"drop","","",7,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",8,{"inputs":[{"name":"unique"},{"name":"mutex"}],"output":{"name":"self"}}],[11,"deref","","",8,null],[11,"deref_mut","","",8,null],[11,"drop","","",8,{"inputs":[{"name":"self"}],"output":null}],[0,"buddy","alloc","Simple buddy-block allocator",null,null],[3,"FreeBlock","alloc::buddy","A free block header stores a pointer to the next and previous free blocks.",null,null],[3,"Heap","","Structure with data for implementing the buddy block allocation strategy.",null,null],[12,"start_addr","","Address of the base of the heap. This must be aligned on a `MIN_ALIGN` boundary.",9,null],[12,"heap_size","","Number of blocks in the heap (must be a power of 2)",9,null],[12,"min_block_size","","Minimum block size",9,null],[0,"system","","This module integrates the buddy heap allocator into the Rust runtime.",null,null],[3,"BuddyFrameAllocator","alloc::buddy::system","A frame allocator using the system's buddy-block heap allocator",null,null],[5,"init_heap","","Initialize the system heap at the given start address",null,null],[5,"__rust_allocate","","",null,null],[5,"__rust_deallocate","","",null,null],[5,"__rust_reallocate","","",null,null],[5,"__rust_reallocate_inplace","","This is currently unsupported, so we just silently ignore it and return the old size.",null,null],[5,"__rust_usable_size","","",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[17,"NUM_FREE_LISTS","","The number of free lists for the kernel heap",null,null],[11,"new","","Construct a new `BuddyFrameAllocator`",10,{"inputs":[],"output":{"name":"self"}}],[6,"FreeList","alloc::buddy","A `FreeList` is a list of unique free blocks",null,null],[11,"prev","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"next","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"prev_mut","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"next_mut","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"new","","Construct a new `Heap`.",9,null],[11,"add_block","","Add a block of max order",9,{"inputs":[{"name":"self"},{"name":"address"}],"output":null}],[11,"alloc_size","","Computes the size of an allocation request.",9,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"alloc_order","","Computes the order of an allocation request.",9,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"get_buddy","","Finds the buddy block for a given block.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"address"}],"output":{"name":"option"}}],[11,"remove_block","","Finds and removes the target block from the free list.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"address"}],"output":{"name":"bool"}}],[11,"alloc","","Returns a pointer suitable for holding data described by `layout`, meeting its size and alignment guarantees.",9,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"dealloc","","Release an allocated block of memory.",9,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[0,"bump_ptr","alloc","",null,null],[3,"BumpPtr","alloc::bump_ptr","A simple bump pointer allocator.",null,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",12,{"inputs":[{"name":"paddr"},{"name":"paddr"}],"output":{"name":"self"}}],[11,"alloc","","",12,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"dealloc","","",12,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[0,"system","alloc","",null,null],[3,"SystemAllocator","alloc::system","",null,null],[4,"Tier","","",null,null],[13,"Uninitialized","","",13,null],[13,"Bump","","",13,null],[13,"Buddy","","",13,null],[11,"deref","","",13,null],[11,"alloc","","",13,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"allocresult"}}],[11,"dealloc","","",13,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[11,"borrow_ptr","","Borrow a raw allocation from the system allocator",14,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"allocresult"}}],[11,"borrow","","Borrow an object allocation from the system allocator.",14,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[6,"AllocResult","alloc","",null,null],[6,"Size","","",null,null],[6,"Capacity","","",null,null],[6,"Alignment","","",null,null],[6,"Address","","",null,null],[8,"Allocator","","An implementation of `Allocator` can allocate, reallocate, and deallocate arbitrary blocks of data described via `Layout`.",null,null],[10,"alloc","","Returns a pointer suitable for holding data described by `layout`, meeting its size and alignment guarantees.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[10,"dealloc","","Deallocate the memory referenced by `ptr`.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[11,"oom","","Allocator-specific method for signalling an out-of-memory condition.",15,null],[11,"usable_size","","Returns bounds on the guaranteed usable size of a successful allocation created with the specified `layout`.",15,null],[11,"realloc","","Returns a pointer suitable for holding data described by `new_layout`, meeting its size and alignment guarantees. To accomplish this, this may extend or shrink the allocation referenced by `ptr` to fit `new_layout`.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"result"}}],[11,"alloc_excess","","Behaves like `fn alloc`, but also returns the whole size of the returned block. For some `layout` inputs, like arrays, this may include extra storage usable for additional data.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"realloc_excess","","Behaves like `fn realloc`, but also returns the whole size of the returned block. For some `layout` inputs, like arrays, this may include extra storage usable for additional data.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"result"}}],[11,"realloc_in_place","","Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"result"}}],[11,"alloc_one","","Allocates a block suitable for holding an instance of `T`.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"dealloc_one","","Deallocates a block suitable for holding an instance of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"}],"output":null}],[11,"alloc_array","","Allocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"realloc_array","","Reallocates a block previously suitable for holding `n_old` instances of `T`, returning a block suitable for holding `n_new` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"dealloc_array","","Deallocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"}],"output":{"name":"result"}}],[11,"alloc_unchecked","","Returns a pointer suitable for holding data described by `layout`, meeting its size and alignment guarantees.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"option"}}],[11,"realloc_unchecked","","Returns a pointer suitable for holding data described by `new_layout`, meeting its size and alignment guarantees. To accomplish this, may extend or shrink the allocation referenced by `ptr` to fit `new_layout`. (In other words, ownership of the memory block associated with `ptr` is first transferred back to this allocator, but the same block may or may not be transferred back as the result of this call.)",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"option"}}],[11,"alloc_excess_unchecked","","Behaves like `fn alloc_unchecked`, but also returns the whole size of the returned block.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"option"}}],[11,"realloc_excess_unchecked","","Behaves like `fn realloc_unchecked`, but also returns the whole size of the returned block.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"option"}}],[11,"alloc_array_unchecked","","Allocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"realloc_array_unchecked","","Reallocates a block suitable for holding `n_old` instances of `T`, returning a block suitable for holding `n_new` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"dealloc_array_unchecked","","Deallocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"}],"output":null}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"layout"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"bool"}}],[11,"from_size_align","","",16,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"layout"}}],[11,"size","","The minimum size in bytes for a memory block of this layout.",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"align","","The minimum byte alignment for a memory block of this layout.",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"new","","Constructs a `Layout` suitable for holding a value of type `T`.",16,{"inputs":[],"output":{"name":"self"}}],[11,"for_value","","Produces layout describing a record that could be used to allocate backing structure for `T` (which could be a trait or other unsized type like a slice).",16,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"align_to","","Creates a layout describing the record that can hold a value of the same layout as `self`, but that also is aligned to alignment `align` (measured in bytes).",16,{"inputs":[{"name":"self"},{"name":"alignment"}],"output":{"name":"self"}}],[11,"padding_needed_for","","Returns the amount of padding we must insert after `self` to ensure that the following address will satisfy `align` (measured in bytes).",16,{"inputs":[{"name":"self"},{"name":"alignment"}],"output":{"name":"usize"}}],[11,"repeat","","Creates a layout describing the record for `n` instances of `self`, with a suitable amount of padding between each to ensure that each instance is given its requested size and alignment. On success, returns `(k, offs)` where `k` is the layout of the array and `offs` is the distance between the start of each element in the array.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"extend","","Creates a layout describing the record for `self` followed by `next`, including any necessary padding to ensure that `next` will be properly aligned. Note that the result layout will satisfy the alignment properties of both `self` and `next`.",16,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"repeat_packed","","Creates a layout describing the record for `n` instances of `self`, with no padding between each instance.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"extend_packed","","Creates a layout describing the record for `self` followed by `next` with no additional padding between the two. Since no padding is inserted, the alignment of `next` is irrelevant, and is not incoporated at all into the resulting layout.",16,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"new_unchecked","","do indirectly validate, but that is not part of their specification.) Creates layout describing the record for a single instance of `T`.",16,{"inputs":[],"output":{"name":"self"}}],[11,"extend_unchecked","","Creates a layout describing the record for `self` followed by `next`, including any necessary padding to ensure that `next` will be properly aligned. Note that the result layout will satisfy the alignment properties of both `self` and `next`.",16,null],[11,"repeat_unchecked","","Creates a layout describing the record for `n` instances of `self`, with a suitable amount of padding between each.",16,null],[11,"repeat_packed_unchecked","","Creates a layout describing the record for `n` instances of `self`, with no padding between each instance.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"extend_packed_unchecked","","Creates a layout describing the record for `self` followed by `next` with no additional padding between the two. Since no padding is inserted, the alignment of `next` is irrelevant, and is not incoporated at all into the resulting layout.",16,null],[11,"array","","Creates a layout describing the record for a `[T; n]`.",16,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"array_unchecked","","Creates a layout describing the record for a `[T; n]`.",16,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"allocerr"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"allocerr"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"allocerr"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"invalid_input","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"is_memory_exhausted","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_request_unsupported","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"cannotreallocinplace"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"cannotreallocinplace"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[4,"AllocErr"],[3,"MemMapAllocator"],[8,"Allocator"],[8,"Lender"],[3,"BorrowedFrame"],[3,"BorrowedFrameRange"],[8,"Lender"],[3,"BorrowedPtr"],[3,"Borrowed"],[3,"Heap"],[3,"BuddyFrameAllocator"],[3,"FreeBlock"],[3,"BumpPtr"],[4,"Tier"],[3,"SystemAllocator"],[8,"Allocator"],[3,"Layout"],[3,"CannotReallocInPlace"]]};
searchIndex["arrayvec"] = {"doc":"arrayvec provides the types `ArrayVec` and `ArrayString`:  array-backed vector and string types, which store their contents inline.","items":[[8,"RangeArgument","arrayvec","IndexRange is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"end","","End index (exclusive)",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[3,"ArrayString","","A string with a fixed capacity.",null,null],[3,"ArrayVec","","A vector with a fixed capacity.",null,null],[3,"IntoIter","","By-value iterator for `ArrayVec`.",null,null],[3,"Drain","","A draining iterator for `ArrayVec`.",null,null],[3,"CapacityError","","Error value indicating insufficient capacity",null,null],[11,"new","","Create a new empty `ArrayString`.",1,{"inputs":[],"output":{"name":"arraystring"}}],[11,"from","","Create a new `ArrayString` from a `str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_byte_string","","Create a new `ArrayString` from a byte string literal.",1,{"inputs":[{"name":"a"}],"output":{"name":"result"}}],[11,"capacity","","Return the capacity of the `ArrayString`.",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_full","","Return if the `ArrayString` is completely filled.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Adds the given char to the end of the string.",1,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"result"}}],[11,"push_str","","Adds the given string slice to the end of the string.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"clear","","Make the string empty.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"set_len","","Set the strings's length.",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"as_str","","Return a string slice of the whole `ArrayString`.",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref_mut","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"hash","","",1,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"borrow","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"as_ref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"write_char","","",1,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"result"}}],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"arraystring"}}],[11,"clone_from","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[8,"Array","","Trait for fixed size arrays.",null,null],[16,"Item","","The array's element type",2,null],[11,"drop","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Create a new empty `ArrayVec`.",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"len","","Return the number of elements in the `ArrayVec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"capacity","","Return the capacity of the `ArrayVec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_full","","Return if the `ArrayVec` is completely filled.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Push `element` to the end of the vector.",3,null],[11,"insert","","Insert `element` in position `index`.",3,null],[11,"pop","","Remove the last element in the vector.",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"swap_remove","","Remove the element at `index` and swap the last element into its place.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"remove","","Remove the element at `index` and shift down the following elements.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"clear","","Remove all elements in the vector.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"retain","","Retains only the elements specified by the predicate.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"set_len","","Set the vector's length without dropping or moving out elements",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"drain","","Create a draining iterator that removes the specified range in the vector and yields the removed items from start to end. The element range is removed even if the iterator is not consumed until the end.",3,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"drain"}}],[11,"into_inner","","Return the inner fixed size array, if it is full to its capacity.",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"dispose","","Dispose of `self` without the overwriting that is needed in Drop.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"as_slice","","Return a slice containing all elements of the vector.",3,null],[11,"as_mut_slice","","Return a mutable slice containing all elements of the vector.",3,null],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"from","","",3,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"into_iter","","",3,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop","","",4,{"inputs":[{"name":"self"}],"output":null}],[11,"next","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[11,"next_back","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"extend","","",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone_from","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"hash","","",3,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",3,null],[11,"borrow","","",3,null],[11,"borrow_mut","","",3,null],[11,"as_ref","","",3,null],[11,"as_mut","","",3,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"arrayvec"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"cmp","","",3,{"inputs":[{"name":"self"},{"name":"arrayvec"}],"output":{"name":"ordering"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"capacityerror"}}],[11,"cmp","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"ordering"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"self"},{"name":"capacityerror"}],"output":{"name":"bool"}}],[11,"element","","Extract the overflowing element",6,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"simplify","","Convert into a `CapacityError` that does not carry an element.",6,{"inputs":[{"name":"self"}],"output":{"name":"capacityerror"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[8,"RangeArgument"],[3,"ArrayString"],[8,"Array"],[3,"ArrayVec"],[3,"IntoIter"],[3,"Drain"],[3,"CapacityError"]]};
searchIndex["bitflags"] = {"doc":"A typesafe bitmask flag generator.","items":[[14,"bitflags","bitflags","The `bitflags!` macro generates a `struct` that holds a set of C-style bitmask flags. It is useful for creating typesafe wrappers for C APIs.",null,null]],"paths":[]};
searchIndex["cpu"] = {"doc":"","items":[[3,"Registers","cpu","Registers pushed to the stack when handling an interrupt or context switch.",null,null],[12,"rsi","","",0,null],[12,"rdi","","",0,null],[12,"r11","","",0,null],[12,"r10","","",0,null],[12,"r9","","",0,null],[12,"r8","","",0,null],[12,"rdx","","",0,null],[12,"rcx","","",0,null],[12,"rax","","",0,null],[3,"UnsafePort","","",null,null],[3,"Port","","A CPU I/O port.",null,null],[4,"PrivilegeLevel","","Represents an x86 privilege level.",null,null],[13,"KernelMode","","Ring 0 is the most privileged ring",1,null],[13,"Ring1","","",1,null],[13,"Ring2","","",1,null],[13,"UserMode","","Ring 3 is the least privileged ring",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"privilegelevel"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"privilegelevel"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"privilegelevel"}],"output":{"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"privilegelevel"}],"output":{"name":"ordering"}}],[11,"current_iopl","","Returns the current I/O Privilege Level from `%eflags`/`%rflags`.",1,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",2,{"inputs":[{"name":"u16"}],"output":{"name":"unsafeport"}}],[11,"in8","","Read a byte (8 bits) from this port",2,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"in16","","Read a word (16 bits) from this port",2,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"in32","","Read a long word (32 bits) from this port",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"out8","","",2,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"out16","","",2,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"out32","","",2,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"read","","Reads a single byte into the given buffer",2,null],[11,"read_all","","Reads a new byte into each position in the buffer.",2,null],[11,"write","","",2,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"registers"}}],[11,"to_array","","Transform this struct into an array of `u64`s (if you would ever want to do this) TODO: rewrite this to be a `convert::Into` implementation.",0,null],[11,"empty","","Create a new empty set of Registers",0,{"inputs":[],"output":{"name":"self"}}],[11,"push","","Push the caller-saved registers to the stack (such as when handling a context switch or interrupt).",0,{"inputs":[],"output":null}],[11,"pop","","Push the caller-saved registers off the stack (such as when handling a context switch or interrupt).",0,{"inputs":[],"output":null}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"context","","`x86_64` execution contexts.",null,null],[3,"Registers","cpu::context","Registers pushed to the stack when handling an interrupt or context switch.",null,null],[12,"rsi","","",0,null],[12,"rdi","","",0,null],[12,"r11","","",0,null],[12,"r10","","",0,null],[12,"r9","","",0,null],[12,"r8","","",0,null],[12,"rdx","","",0,null],[12,"rcx","","",0,null],[12,"rax","","",0,null],[3,"InterruptFrame","","",null,null],[12,"rip","","Value of the instruction pointer (`$rip`) register",3,null],[12,"cs","","Value of the code segment (`$cs`) register",3,null],[12,"rflags","","Value of the CPU flags (`$rflags`) register",3,null],[12,"rsp","","Value of the stack pointer (`$rsp`) register",3,null],[12,"ss","","Value of the stack segment (`$ss`) register",3,null],[3,"Context","","Thread execution context",null,null],[12,"rsp","","Value of the stack pointer (`rsp`) register",4,null],[12,"registers","","Value of the caller-saved registers",4,null],[12,"rip","","Value of the instruction pointer (`rip`) register",4,null],[0,"task","cpu","Tasking",null,null],[3,"StateDescriptor","cpu::task","A 64-bit Task State Descriptor",null,null],[12,"upper","","",5,null],[12,"lower","","",5,null],[3,"StateSegment","","A 64-bit Task State Segment",null,null],[12,"rsp","","64-bit values of the stack pointers (`%rsp`) for privilege rings 0-2",6,null],[12,"ist","","64-bit values of the interrupt stack table registers",6,null],[12,"iomap_base_offset","","the base offset of the IO map",6,null],[0,"msr","cpu","Code for interacting with the Model-Specific Registers (MSRs).",null,null],[5,"write","cpu::msr","Write `value` to the specified `msr`",null,{"inputs":[{"name":"u32"},{"name":"u64"}],"output":null}],[5,"read","","Read 64 bits from the specified `msr`",null,{"inputs":[{"name":"u32"}],"output":{"name":"u64"}}],[5,"enable_nxe","","Enable the NXE (No Execute) in the IA-32 EFER register.",null,{"inputs":[],"output":null}],[17,"IA32_EFER","","Extended Feature Enable Register (EFER) on IA-32",null,null],[0,"control_regs","cpu","`x86` and `x86_64` control registers",null,null],[3,"CrState","cpu::control_regs","A struct bundling together a snapshot of the control registers state.",null,null],[12,"cr0","","`%cr0` contains flags that control the CPU's operations",7,null],[12,"cr2","","`%cr2` contains the page fault linear address",7,null],[12,"cr3","","`%cr3` contains the page table root pointer",7,null],[12,"cr4","","`%cr4` contains flags that control operations in protected mode",7,null],[5,"dump","","Dump the current contents of the control registers to a `CrState`.",null,{"inputs":[],"output":{"name":"crstate"}}],[0,"cr0","","`%cr0` contains flags that modify basic processor operation.",null,null],[3,"Flags","cpu::control_regs::cr0","Flag present in `%cr0`.",null,null],[5,"is_paging_enabled","","If set, enable paging; if unset, disable paging.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"enable_paging","","If set, enable paging; if unset, disable paging.",null,{"inputs":[{"name":"bool"}],"output":null}],[5,"is_write_protected","","If set, enable the write protect bit; if unset, disable write protect.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"enable_write_protect","","If set, enable the write protect bit; if unset, disable write protect.",null,{"inputs":[{"name":"bool"}],"output":null}],[5,"read","","Read the current value from `%cr0`.",null,{"inputs":[],"output":{"name":"flags"}}],[5,"write","","Write a value to `%cr0`.",null,{"inputs":[{"name":"flags"}],"output":null}],[17,"PE","","Protected Mode Enable",null,null],[17,"MP","","Monitor co-processor",null,null],[17,"EM","","FPU Emulation",null,null],[17,"TS","","Task Switched",null,null],[17,"ET","","Extension Type",null,null],[17,"NE","","Numeric Error",null,null],[17,"WP","","Write Protect",null,null],[17,"AM","","Alignment Mask",null,null],[17,"NW","","Not Write-Through",null,null],[17,"CD","","Cache Disable",null,null],[17,"PG","","Paging",null,null],[0,"cr4","cpu::control_regs","`%cr4` contains flags that control protected mode execution.",null,null],[3,"Flags","cpu::control_regs::cr4","Bitflags present in `$cr4`",null,null],[5,"read","","Read the current value from `$cr4`.",null,{"inputs":[],"output":{"name":"flags"}}],[5,"write","","Write a value to `$cr4`.",null,{"inputs":[{"name":"flags"}],"output":null}],[5,"is_timestamp_disabled","","If disabled, the `RTDSC` instruction can only be executed in Ring 0.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"disable_timestamp","","If disabled, the `RTDSC` instruction can only be executed in Ring 0.",null,{"inputs":[{"name":"bool"}],"output":null}],[17,"VME","","Virtual 8086 Mode Extensions",null,null],[17,"PVI","","Protected-mode Virtual Interrupts",null,null],[17,"TSD","","Time Stamp Disable",null,null],[17,"DE","","Debugging Extensions",null,null],[17,"PSE","","Page Size Extension",null,null],[17,"PAE","","Physical Address Extension",null,null],[17,"MCE","","Machine Check Exception",null,null],[17,"PGE","","Page Global Enabled",null,null],[17,"PCE","","Performance-Monitoring Counter enable",null,null],[17,"OSFXSR","","Operating system support for `FXSAVE` and `FXRSTOR` instructions",null,null],[17,"OSXMMEXCPT","","Operating System Support for Unmasked SIMD Floating-Point Exceptions",null,null],[17,"VMXE","","Virtual Machine Extensions Enable",null,null],[17,"SMXE","","Safer Mode Extensions Enable",null,null],[17,"FSGSBASE","","Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.",null,null],[17,"PCIDE","","PCID Enable",null,null],[17,"OSXSAVE","","`XSAVE` and Processor Extended States Enable",null,null],[17,"SMEP","","Supervisor Mode Execution Protection Enable",null,null],[17,"SMAP","","Supervisor Mode Access Protection Enable",null,null],[17,"PKE","","Protection Key Enable",null,null],[0,"cr2","cpu::control_regs","`$cr2` contains the page fault linear address",null,null],[5,"read","cpu::control_regs::cr2","Read the current value from `$cr2`.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"write","","Write a value to `$cr2`.",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"cr3","cpu::control_regs","`%cr3` contains the page table root pointer",null,null],[5,"read","cpu::control_regs::cr3","Read the current value from `$cr3`.",null,{"inputs":[],"output":{"name":"paddr"}}],[5,"write","","Write a value to `$cr3`.",null,{"inputs":[{"name":"paddr"}],"output":null}],[5,"current_pagetable_frame","","Returns the current Page Directory base frame.",null,{"inputs":[],"output":{"name":"physicalpage"}}],[5,"set_pagetable_frame","","Returns the current Page Directory base frame.",null,{"inputs":[{"name":"physicalpage"}],"output":null}],[0,"segment","cpu","Code for using the `x86` and `x86_64` segmentation hardware.",null,null],[3,"Gdt","cpu::segment","Structure representing a Global Descriptor Table",null,null],[12,"code","","The code segment descriptor",8,null],[3,"Selector","","A segment selector is a 16-bit identifier for a segment.",null,null],[3,"Descriptor","","A segment descriptor is an entry in an IDT or GDT.",null,null],[12,"base_high","","The last 8 bits of the base address",9,null],[12,"flags","","The next 16 bits are bitflags",9,null],[12,"base_mid","","The middle 8 bits of the base address",9,null],[12,"base_low","","The first 16 bits of the base address",9,null],[12,"limit","","the segment limit",9,null],[3,"Flags","","Segment descriptor bitflags field.",null,null],[3,"DataFlags","","The type-specific section of a data segment's flags",null,null],[3,"CodeFlags","","The type-specific section of a code segment's flags",null,null],[4,"Type","","Possible ways to interpret the type bits of a segment selector.",null,null],[13,"System","","The type bits interpreted as a system segment",10,null],[13,"Code","","The type bits interpreted as a code segment",10,null],[13,"Data","","The type bits interpreted as a data segment",10,null],[4,"SysType","","Possible types of for a system segment.",null,null],[13,"Ldt","","System segment used for storing a local descriptor table.",11,null],[13,"TssAvailable","","An available translation stack segment.",11,null],[13,"TssBusy","","A busy translation stack segment",11,null],[13,"CallGate","","A call gate system segment",11,null],[13,"InterruptGate","","An interrupt gate system segment",11,null],[13,"TrapGate","","A trap gate system segment",11,null],[7,"GDT","","A Global Descriptor Table (GDT)",null,null],[17,"GDT_SIZE","","The number of entries in the GDT",null,null],[17,"RPL_RING_0","","Set if the RPL is in Ring 0",null,null],[17,"RPL_RING_1","","Set if the RPL is in Ring 1",null,null],[17,"RPL_RING_2","","Set if the RPL is in Ring 2",null,null],[17,"RPL_RING_3","","Set if the RPL is in Ring 3",null,null],[17,"RPL","","Requested Privelege Level (RPL) bits",null,null],[17,"TI_GDT","","If the Table Indicator (TI) is 0, use the GDT",null,null],[17,"TI_LDT","","If the TI is 1, use the LDT",null,null],[17,"CODE_DATA_ACC","","1 if this is a code or data segment that has been accessed",null,null],[17,"SEGMENT_TYPE","","Four bits that indcate the type of the segment",null,null],[17,"DESCR_TYPE","","1 if this is a data/code segment, 0 if this is a system segment",null,null],[17,"DPL","","Two bits indicating the descriptor priveliege level",null,null],[17,"PRESENT","","1 if this segment is present.",null,null],[17,"LIMIT","","bits 16...19 of the limit",null,null],[17,"AVAILABLE","","1 if this segment is available for use by system software",null,null],[17,"LENGTH","","0 if this is a 16- or 32-bit segment, 1 if it is a 64-bit segment",null,null],[17,"DEFAULT_SIZE","","0 if this is a 16-bit segment, 1 if it is a 32-bit segment",null,null],[17,"GRANULARITY","","0 if the limit of this segment is given in bytes, 1 if it is given in 4092-byte pages",null,null],[17,"ACCESSED","","If this is a code or data segment and the accessed bit is set, it has been accessed.",null,null],[17,"DATA_ACCESSED","","0 if this segment hasn't been accessed, 1 if it has",null,null],[17,"WRITE","","0 if this segment is read-only, 1 if it is read-write",null,null],[17,"EXPAND_DOWN","","1 if this segment expands down",null,null],[17,"CODE_ACCESSED","","0 if this segment hasn't been accessed, 1 if it has",null,null],[17,"READ","","0 if this segment is read-only, 1 if it is read-write",null,null],[17,"EXECUTE","","0 if this segment is not executable, 1 if it is executable",null,null],[17,"CONFORMING","","0 if this segment is non-conforming, 1 if it is conforming",null,null],[17,"EXEC_ONLY","","Whether this segment is execute-only",null,null],[0,"dtable","cpu","`x86` and `x86_64` descriptor tables (IDT, GDT, or LDT)",null,null],[3,"Pointer","cpu::dtable","A pointer to a descriptor table. This is a format suitable",null,null],[12,"limit","","the length of the descriptor table",12,null],[12,"base","","pointer to the region in memory containing the descriptor table.",12,null],[8,"DTable","","A descriptor table (IDT or GDT).",null,null],[16,"Entry","","The type of an entry in this descriptor table.",13,null],[11,"get_ptr","","Get the IDT pointer struct to pass to `lidt` or `lgdt`",13,{"inputs":[{"name":"self"}],"output":{"name":"pointer"}}],[10,"entry_count","","Returns the number of Entries in the `DTable`.",13,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"load","","Load the descriptor table with the appropriate load instruction",13,{"inputs":[{"name":"self"}],"output":null}],[0,"flags","cpu","Flags present in the `%eflags`/`%rflags` register on x86 CPUs.",null,null],[3,"Flags","cpu::flags","Contents of the `%eflags`/`%rflags` register.",null,null],[5,"read","","Read the current value from `$eflags`/`%rflags`.",null,{"inputs":[],"output":{"name":"flags"}}],[17,"CF","","Carry flag",null,null],[17,"PF","","Parity flag",null,null],[17,"AF","","Adjust flag",null,null],[17,"ZF","","Zero flag",null,null],[17,"SF","","Sign flag",null,null],[17,"TF","","Trap flag (single step)",null,null],[17,"IF","","Interrupt enable flag",null,null],[17,"DF","","Direction flag",null,null],[17,"OF","","Overflow flag",null,null],[17,"IOPL_RING_0","","",null,null],[17,"IOPL_RING_1","","",null,null],[17,"IOPL_RING_2","","",null,null],[17,"IOPL_RING_3","","",null,null],[17,"IOPL","","I/0 Privilege Level",null,null],[17,"NT","","Nested task flag",null,null],[17,"RESERVED","","Should always be 1",null,null],[17,"RF","","Resume flag",null,null],[17,"VM","","Virtual 8086 Mode flag",null,null],[17,"AC","","Alignment Check",null,null],[17,"VIF","","Virtual Interrupt flag",null,null],[17,"VIP","","Virtual Interrupt Pending",null,null],[17,"ID","","Able to use `CPUID` instruction.",null,null],[0,"timer","cpu","Code for interacting with the system timer & timestamp register.",null,null],[0,"timestamp","cpu::timer","x86 Timestamp register",null,null],[5,"rtdsc","cpu::timer::timestamp","Read the current value of the timestamp counter.",null,{"inputs":[],"output":{"name":"u64"}}],[5,"rtdscp","","Read the current timestamp, after other instructions have been executed.",null,{"inputs":[],"output":{"name":"u64"}}],[5,"is_available","","Returns true if timestamps are currently available.",null,{"inputs":[],"output":{"name":"result"}}],[5,"get_timestamp","","Returns the current timestamp, or an error",null,{"inputs":[],"output":{"name":"result"}}],[5,"wait_get_timestamp","","Returns the current timestamp or an error, after other instructions have been executed.",null,{"inputs":[],"output":{"name":"result"}}],[0,"interrupts","cpu","Intterupt handling on x86 machines.",null,null],[3,"ExceptionInfo","cpu::interrupts","A description of a CPU exception",null,null],[12,"name","","The name of the exception",14,null],[12,"mnemonic","","The mnemomic code for the exception",14,null],[12,"irq_type","","The type of IRQ for this exception - fault - trap - interrupt",14,null],[12,"source","","The source triggering the exception.",14,null],[5,"timer","","Handler for the system timer interrupt",null,{"inputs":[{"name":"interruptframe"}],"output":null}],[5,"page_fault","","Handles page fault exceptions",null,{"inputs":[{"name":"interruptframe"},{"name":"usize"}],"output":null}],[5,"test","","Test interrupt handler for ensuring that the IDT is configured correctly.",null,{"inputs":[{"name":"interruptframe"}],"output":null}],[0,"idt","","Common functionality for the `x86` and `x86_64` Interrupt Descriptor Table.",null,null],[3,"Gate","cpu::interrupts::idt","An IDT entry is called a gate.",null,null],[12,"offset_lower","","bits 0 - 15 of the offset",15,null],[12,"selector","","code segment selector (GDT or LDT)",15,null],[12,"flags","","indicates the gate's type and attributes. the second half indicates the type:   + `0b1100`: Call gate   + `0b1110`: Interrupt gate   + `0b1111`: Trap Gate",15,null],[12,"offset_mid","","bits 16 - 31 of the offset",15,null],[12,"offset_upper","","bits 32 - 63 of the offset",15,null],[3,"GateFlags","","Bitflags field in an IDT gate.",null,null],[3,"Idt","","An Interrupt Descriptor Table",null,null],[12,"divide_by_zero","","",16,null],[12,"debug","","debug interrupt handler - reserved",16,null],[12,"nmi","","",16,null],[12,"breakpoint","","",16,null],[12,"overflow","","",16,null],[12,"bound_exceeded","","",16,null],[12,"undefined_opcode","","",16,null],[12,"device_not_available","","",16,null],[12,"double_fault","","",16,null],[12,"invalid_tss","","",16,null],[12,"segment_not_present","","",16,null],[12,"stack_segment_fault","","",16,null],[12,"general_protection_fault","","",16,null],[12,"page_fault","","",16,null],[12,"floating_point_error","","",16,null],[12,"alignment_check","","",16,null],[12,"machine_check","","",16,null],[12,"simd_fp_exception","","",16,null],[12,"virtualization","","",16,null],[12,"security_exception","","",16,null],[12,"interrupts","","user-defined interrupts",16,null],[0,"gate","","64-bit IDT gate implementation",null,null],[3,"Gate","cpu::interrupts::idt::gate","An IDT entry is called a gate.",null,null],[12,"offset_lower","","bits 0 - 15 of the offset",15,null],[12,"selector","","code segment selector (GDT or LDT)",15,null],[12,"flags","","indicates the gate's type and attributes. the second half indicates the type:   + `0b1100`: Call gate   + `0b1110`: Interrupt gate   + `0b1111`: Trap Gate",15,null],[12,"offset_mid","","bits 16 - 31 of the offset",15,null],[12,"offset_upper","","bits 32 - 63 of the offset",15,null],[17,"ENTRIES","cpu::interrupts::idt","Number of entries in the system's Interrupt Descriptor Table.",null,null],[17,"PRESENT","","Set to 0 for unused interrupts.",null,null],[17,"DPL_RING_0","","Bit indicating that the descriptor priveliege level is Ring 0",null,null],[17,"DPL_RING_1","","Bit indicating that the descriptor priveliege level is Ring 1",null,null],[17,"DPL_RING_2","","Bit indicating that the descriptor priveliege level is Ring 2",null,null],[17,"DPL_RING_3","","Bit indicating that the descriptor priveliege level is Ring 3",null,null],[17,"DPL","","Descriptor priveliege level bitfield.",null,null],[17,"SEGMENT","","Storage segment flag.",null,null],[17,"LONG_MODE","","Set if this `Gate` points to a 32-bit ISR.",null,null],[17,"INT_GATE_16","","Set if this is an interrupt gate.",null,null],[17,"INT_GATE_32","","Set if this is an interrupt gate and points to a 32-bit ISR.",null,null],[17,"TRAP_GATE_16","","Set if this is a trap gate.",null,null],[17,"TRAP_GATE_32","","Set if this is a trap gate that points to a 32-bit ISR",null,null],[17,"TASK_GATE_32","","Set if this is a 32-bit task gate.",null,null],[0,"pics","cpu::interrupts","Support for the 8259 Programmable Interrupt Controller.",null,null],[3,"PIC","cpu::interrupts::pics","A 8259 Programmable Interrupt Controller.",null,null],[4,"IRQ","","List of IRQs on the x86.",null,null],[13,"Timer","","System timer IRQ",17,null],[13,"PS2Keyboard","","PS/2 keyboard controller",17,null],[13,"Cascade","","PIC2 cascade IRQ",17,null],[13,"COM2","","COM2 serial port",17,null],[13,"COM1","","COM1 serial port",17,null],[13,"LPT2","","Line printer 2",17,null],[13,"Floppy","","Floppy disc controller",17,null],[13,"LPT1","","Line printer 1",17,null],[13,"RTCTimer","","CMOS clock",17,null],[13,"PS2Mouse","","PS/2 mouse controller",17,null],[13,"FPU","","Floating-point Coprocessor",17,null],[13,"PrimaryATA","","ATA channel 1",17,null],[13,"SecondaryATA","","ATA channel 2",17,null],[5,"initialize","","Initialize the system's Programmable Interrupt Controller",null,{"inputs":[],"output":null}],[5,"end_pic_interrupt","","If an interrupt is being handled by the PICs, end that interrupt.",null,{"inputs":[{"name":"u8"}],"output":null}],[6,"InterruptHandler","cpu::interrupts","An ISR that handles a regular interrupt",null,null],[6,"ErrorCodeHandler","","An ISR that handles an error with an error code",null,null],[17,"NUM_EXCEPTIONS","","Number of interrupt vectors corresponding to CPU exceptions.",null,null],[11,"new","cpu","",18,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"read","","",18,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"write","","",18,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"new","","",18,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"read","","",18,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"write","","",18,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"new","","",18,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"read","","",18,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"write","","",18,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"eq","cpu::control_regs::cr0","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",19,null],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",19,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",19,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",19,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",19,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",19,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",19,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",19,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",19,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",19,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",19,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","cpu::control_regs::cr4","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",20,null],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",20,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",20,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",20,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",20,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",20,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",20,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",20,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",20,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",20,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","cpu::control_regs","",7,{"inputs":[{"name":"self"}],"output":{"name":"crstate"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"entry_count","cpu::segment","Returns the number of Entries in the `DTable`.",8,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"load","","Load the GDT table with the `lgdt` instruction.",8,{"inputs":[{"name":"self"}],"output":null}],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"selector"}}],[11,"partial_cmp","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"option"}}],[11,"lt","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"le","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"gt","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"ge","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"cmp","","",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"ordering"}}],[11,"hash","","",21,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",21,{"inputs":[],"output":{"name":"selector"}}],[11,"all","","Returns the set containing all flags.",21,{"inputs":[],"output":{"name":"selector"}}],[11,"bits","","Returns the raw value of the flags currently stored.",21,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",21,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",21,{"inputs":[{"name":"u16"}],"output":{"name":"selector"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"selector"}}],[11,"bitor_assign","","Adds the set of flags.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"selector"}}],[11,"bitxor_assign","","Toggles the set of flags.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"selector"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":{"name":"selector"}}],[11,"sub_assign","","Disables all flags enabled in the set.",21,{"inputs":[{"name":"self"},{"name":"selector"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",21,{"inputs":[{"name":"self"}],"output":{"name":"selector"}}],[11,"extend","","",21,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",21,{"inputs":[{"name":"t"}],"output":{"name":"selector"}}],[11,"new","","Create a new `Selector`",21,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"from_raw","","Create a new `Selector` from raw bits",21,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"from_cs","","Returns the current value of the code segment register.",21,{"inputs":[],"output":{"name":"self"}}],[11,"index","","Extracts the index from a segment selector",21,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"set_global","","Sets this segment selector to be a GDT segment.",21,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"set_local","","Sets this segment selector to be an LDT segment.",21,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"set_rpl","","Sets the Requested Priveliege Level (RPL)",21,{"inputs":[{"name":"self"},{"name":"privilegelevel"}],"output":{"name":"self"}}],[11,"get_rpl","","Checks the segment's privelige.",21,{"inputs":[{"name":"self"}],"output":{"name":"privilegelevel"}}],[11,"load_ss","","Load this selector into the stack segment register (`ss`).",21,{"inputs":[{"name":"self"}],"output":null}],[11,"load_ds","","Load this selector into the data segment register (`ds`).",21,{"inputs":[{"name":"self"}],"output":null}],[11,"load_es","","Load this selector into the `es` segment register.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"load_fs","","Load this selector into the `fs` segment register.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"load_gs","","Load this selector into the `gs` segment register.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"load_cs","","Load this selector into the code segment register.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"default","","",21,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"null","","Constructs a new null `Descriptor`",9,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Constructs a new `Descriptor` from a `limit` and a `base` address",9,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[11,"get_limit","","Extract the limit part from the flags and limit fields.",9,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"default","","",9,{"inputs":[],"output":{"name":"self"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",22,null],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",22,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",22,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",22,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",22,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",22,{"inputs":[{"name":"u16"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",22,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",22,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",22,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",22,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"null","","Returns a new set of `Flag`s with all bits set to 0.",22,{"inputs":[],"output":{"name":"self"}}],[11,"from_raw","","Returns a new set of `Flag`s from a raw `u16`",22,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"get_dpl","","Get the Descriptor Privilege Level (DPL) from the flags",22,{"inputs":[{"name":"self"}],"output":{"name":"privilegelevel"}}],[11,"is_system","","Returns true if this segment is a system segment.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_present","","Returns false if this segment is present",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_available","","Returns false if this segment is available to system software",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_accessed","","Returns true if this is a code or data segment that has been accessed.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_system_type","","Returns the system type indicator, if this is a system segment.",22,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"get_code_type","","Returns the code type indicator.",22,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"get_data_type","","Returns the data type indicator.",22,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"systype"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"systype"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"dataflags"}}],[11,"partial_cmp","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"option"}}],[11,"lt","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"le","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"gt","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"ge","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"cmp","","",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"ordering"}}],[11,"hash","","",23,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",23,{"inputs":[],"output":{"name":"dataflags"}}],[11,"all","","Returns the set containing all flags.",23,{"inputs":[],"output":{"name":"dataflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",23,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",23,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",23,{"inputs":[{"name":"u16"}],"output":{"name":"dataflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"dataflags"}}],[11,"bitor_assign","","Adds the set of flags.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"dataflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"dataflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":{"name":"dataflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",23,{"inputs":[{"name":"self"},{"name":"dataflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",23,{"inputs":[{"name":"self"}],"output":{"name":"dataflags"}}],[11,"extend","","",23,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",23,{"inputs":[{"name":"t"}],"output":{"name":"dataflags"}}],[11,"is_read_only","","Returns true if the data segment is read-only",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_accessed","","Returns true if the data segment has been accessed",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_expand_down","","Returns true if the data segment expands down",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"codeflags"}}],[11,"partial_cmp","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"option"}}],[11,"lt","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"le","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"gt","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"ge","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"cmp","","",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"ordering"}}],[11,"hash","","",24,null],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",24,{"inputs":[],"output":{"name":"codeflags"}}],[11,"all","","Returns the set containing all flags.",24,{"inputs":[],"output":{"name":"codeflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",24,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",24,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",24,{"inputs":[{"name":"u16"}],"output":{"name":"codeflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"codeflags"}}],[11,"bitor_assign","","Adds the set of flags.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"codeflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"codeflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":{"name":"codeflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",24,{"inputs":[{"name":"self"},{"name":"codeflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",24,{"inputs":[{"name":"self"}],"output":{"name":"codeflags"}}],[11,"extend","","",24,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",24,{"inputs":[{"name":"t"}],"output":{"name":"codeflags"}}],[11,"is_exec_only","","Returns true if the code segment is execute-only (not readable)",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_readable","","Returns true if the code segment is readable",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_accessed","","Returns true if the code segment has been accessed.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_conforming","","Returns true if the code segment is conforming.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_ptr","cpu::dtable","Get the IDT pointer struct to pass to `lidt` or `lgdt`",13,{"inputs":[{"name":"self"}],"output":{"name":"pointer"}}],[11,"eq","cpu::flags","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",25,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",25,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",25,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",25,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",25,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",25,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",25,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",25,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",25,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",25,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",25,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",25,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"iopl","","",25,{"inputs":[{"name":"self"}],"output":{"name":"privilegelevel"}}],[11,"new_trap","cpu::interrupts::idt","Returns a new trap gate",26,{"inputs":[],"output":{"name":"self"}}],[11,"new_task","","Returns a new call gate",26,{"inputs":[],"output":{"name":"self"}}],[11,"new_interrupt","","Returns a new interrupt gate",26,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"gate"}}],[11,"absent","","Creates a new IDT gate marked as `absent`.",15,{"inputs":[],"output":{"name":"self"}}],[11,"set_handler","","Set the handler function corresponding to this gate.",15,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"self"}}],[11,"set_trap","","Sets the TRAP GATE flag to true",15,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"self"}}],[11,"deref","","",15,null],[11,"deref_mut","","",15,null],[11,"from","","Creates a new IDT gate pointing at the given handler function.",15,{"inputs":[{"name":"interrupthandler"}],"output":{"name":"self"}}],[11,"from","","Creates a new IDT gate pointing at the given handler function.",15,{"inputs":[{"name":"errorcodehandler"}],"output":{"name":"self"}}],[11,"from","","Creates a new IDT gate pointing at the given handler function.",15,null],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"ne","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"gateflags"}}],[11,"partial_cmp","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"option"}}],[11,"lt","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"le","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"gt","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"ge","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"cmp","","",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"ordering"}}],[11,"hash","","",26,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",26,{"inputs":[],"output":{"name":"gateflags"}}],[11,"all","","Returns the set containing all flags.",26,{"inputs":[],"output":{"name":"gateflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",26,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",26,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",26,{"inputs":[{"name":"u8"}],"output":{"name":"gateflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"gateflags"}}],[11,"bitor_assign","","Adds the set of flags.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"gateflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"gateflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":{"name":"gateflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",26,{"inputs":[{"name":"self"},{"name":"gateflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",26,{"inputs":[{"name":"self"}],"output":{"name":"gateflags"}}],[11,"extend","","",26,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",26,{"inputs":[{"name":"t"}],"output":{"name":"gateflags"}}],[11,"is_trap","","Returns true if this `Gate` is a trap gate",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_present","","Returns true if this `Gate` points to a present ISR",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_present","","Sets the present bit for this gate",26,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"self"}}],[11,"get_dpl","","Checks the gate's privilege",26,{"inputs":[{"name":"self"}],"output":{"name":"privilegelevel"}}],[11,"set_dpl","","Sets the privilege level of the gate",26,{"inputs":[{"name":"self"},{"name":"privilegelevel"}],"output":{"name":"self"}}],[11,"default","","",26,{"inputs":[],"output":{"name":"self"}}],[11,"default","","",16,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"gate"}}],[11,"index_mut","","",16,null],[11,"new","","Construct a new IDT with all interrupt gates set to [`absent`].",16,{"inputs":[],"output":{"name":"self"}}],[11,"enable_interrupts","","Enable interrupts",16,{"inputs":[],"output":null}],[11,"disable_interrupts","","Disable interrupts",16,{"inputs":[],"output":null}],[11,"add_handler","","Add a new interrupt gate pointing to the given handler",16,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"handler"}],"output":{"name":"self"}}],[11,"add_gate","","Add a `Gate` to the IDT.",16,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"gate"}],"output":{"name":"self"}}],[11,"entry_count","","",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"load","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"eq","cpu::interrupts::pics","",17,{"inputs":[{"name":"self"},{"name":"irq"}],"output":{"name":"bool"}}],[11,"cmp","","",17,{"inputs":[{"name":"self"},{"name":"irq"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",17,{"inputs":[{"name":"self"},{"name":"irq"}],"output":{"name":"option"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"irq"}}],[11,"leader","","Construct a new leader PIC",27,{"inputs":[],"output":{"name":"pic"}}],[11,"follower","","Construct a new follower PIC",27,{"inputs":[],"output":{"name":"pic"}}],[11,"is_leader","","Returns true if this PIC is the leader PIC",27,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"send_data","","Send a byte of data to the PIC",27,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"initialize","","Send the \"initialize\" command to this PIC",27,{"inputs":[{"name":"self"}],"output":null}],[11,"read_isr","","Read the contents of the ISR (Interrupt Service Register) from this PIC",27,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"read_irr","","Read the contents of the IRR (Interrupt Request Register) from this PIC",27,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"fmt","cpu::interrupts","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","cpu::context","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","",4,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","cpu::task","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Returns a new, empty TSS",6,{"inputs":[],"output":{"name":"self"}}]],"paths":[[3,"Registers"],[4,"PrivilegeLevel"],[3,"UnsafePort"],[3,"InterruptFrame"],[3,"Context"],[3,"StateDescriptor"],[3,"StateSegment"],[3,"CrState"],[3,"Gdt"],[3,"Descriptor"],[4,"Type"],[4,"SysType"],[3,"Pointer"],[8,"DTable"],[3,"ExceptionInfo"],[3,"Gate"],[3,"Idt"],[4,"IRQ"],[3,"Port"],[3,"Flags"],[3,"Flags"],[3,"Selector"],[3,"Flags"],[3,"DataFlags"],[3,"CodeFlags"],[3,"Flags"],[3,"GateFlags"],[3,"PIC"]]};
searchIndex["elf"] = {"doc":"Parsing and loading Executable and Linkable Format (ELF) 32- and 64-bit binaries.","items":[[3,"Image","elf","A handle on a parsed ELF binary TODO: do we want this to own a HashMap of section names to section headers,       to speed up section lookup?",null,null],[12,"header","","the binary's file header",0,null],[12,"sections","","references to each section header",0,null],[12,"program_headers","","references to each program header",0,null],[0,"section","","",null,null],[3,"HeaderRepr","elf::section","Raw representation of an ELF section header in an ELF binary.",null,null],[3,"Flags","","",null,null],[3,"GroupFlags","","",null,null],[3,"Sections","","Iterator over ELF64 sections",null,null],[3,"StrTable","","An ELF string table.",null,null],[3,"Strings","","Iterator over the strings in an ELF string table",null,null],[4,"Contents","","",null,null],[13,"Empty","","",1,null],[13,"Undefined","","",1,null],[13,"Group","","",1,null],[12,"flags","elf::section::Contents","",1,null],[12,"indicies","","",1,null],[4,"Type","elf::section","Enum representing an ELF file section type.",null,null],[13,"Null","","Section type 0: `SHT_NULL`",2,null],[13,"ProgramBits","","Section type 1: `SHT_PROGBITS`",2,null],[13,"SymbolTable","","Section type 2: `SHT_SYMTAB`",2,null],[13,"StringTable","","Section type 3: `SHT_STRTAB`",2,null],[13,"Rela","","Section type 4: `SHT_RELA`",2,null],[13,"HashTable","","Section type 5: `SHT_HASH`",2,null],[13,"Dynamic","","Section type 6: `SHT_DYNAMIC`",2,null],[13,"Notes","","Section type 7: `SHT_NOTE`",2,null],[13,"NoBits","","Section type 8: `SHT_NOBITS`",2,null],[13,"Rel","","Section type 9: `SHT_REL`",2,null],[13,"Shlib","","Section type 10: `SHT_SHLIB`",2,null],[13,"DynSymTable","","Section type 11: `SHT_DYNSYM`",2,null],[13,"InitArray","","",2,null],[13,"FiniArray","","",2,null],[13,"PreInitArray","","",2,null],[13,"Group","","",2,null],[13,"SymbolTableShIndex","","",2,null],[13,"OsSpecific","","",2,null],[13,"ProcessorSpecific","","",2,null],[13,"User","","",2,null],[17,"SHN_UNDEF","","",null,null],[17,"SHN_LORESERVE","","",null,null],[17,"SHN_LOPROC","","",null,null],[17,"SHN_HIPROC","","",null,null],[17,"SHN_LOOS","","",null,null],[17,"SHN_HIOS","","",null,null],[17,"SHN_ABS","","",null,null],[17,"SHN_COMMON","","",null,null],[17,"SHN_XINDEX","","",null,null],[17,"SHN_HIRESERVE","","",null,null],[17,"SHT_LOOS","","",null,null],[17,"SHT_HIOS","","",null,null],[17,"SHT_LOPROC","","",null,null],[17,"SHT_HIPROC","","",null,null],[17,"SHT_LOUSER","","",null,null],[17,"SHT_HIUSER","","",null,null],[17,"SHF_WRITE","","",null,null],[17,"SHF_ALLOC","","",null,null],[17,"SHF_EXECINSTR","","",null,null],[17,"SHF_MERGE","","",null,null],[17,"SHF_STRINGS","","",null,null],[17,"SHF_INFO_LINK","","",null,null],[17,"SHF_LINK_ORDER","","",null,null],[17,"SHF_OS_NONCONFORMING","","",null,null],[17,"SHF_GROUP","","",null,null],[17,"SHF_TLS","","",null,null],[17,"SHF_COMPRESSED","","",null,null],[17,"SHF_MASKOS","","",null,null],[17,"SHF_MASKPROC","","",null,null],[17,"GRP_COMDAT","","",null,null],[17,"GRP_MASKOS","","",null,null],[17,"GRP_MASKPROC","","",null,null],[8,"Header","","Represents an ELF section header",null,null],[16,"Word","","",3,null],[11,"end_address","","Returns the end address of this section TODO: refactor this to return a Range instead?",3,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"is_writable","","Returns true if this section is writable.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_allocated","","Returns true if this section occupies memory during program execution.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_executable","","Returns true if this section contains executable instructions.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_mergeable","","Returns true if this section can be merged.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_uniform","","Returns true if this section contains data that is of a uniform size.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get_name","","Look up the name of this section in the passed string table.",3,{"inputs":[{"name":"self"},{"name":"strtable"}],"output":{"name":"str"}}],[10,"name_offset","","",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"get_type","","This member categorizes the section's contents and semantics.",3,{"inputs":[{"name":"self"}],"output":{"name":"elfresult"}}],[10,"flags","","",3,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[10,"address","","",3,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[10,"offset","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"length","","TODO: should offset + length make a Range?",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"link","","",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"info","","",3,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"address_align","","",3,null],[10,"entry_length","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get_type","","Returns the type of this section",4,{"inputs":[{"name":"self"}],"output":{"name":"elfresult"}}],[11,"name_offset","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"flags","","",4,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"address","","TODO: shold this return a PAddr?",4,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"offset","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"length","","TODO: should offset + length make a Range?",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"link","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"info","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"address_align","","",4,null],[11,"entry_length","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_type","","Returns the type of this section",4,{"inputs":[{"name":"self"}],"output":{"name":"elfresult"}}],[11,"name_offset","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"flags","","",4,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"address","","TODO: shold this return a PAddr?",4,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"offset","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"length","","TODO: should offset + length make a Range?",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"link","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"info","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"address_align","","",4,null],[11,"entry_length","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",5,null],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",5,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",5,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",5,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",5,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",5,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",5,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",5,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",5,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"groupflags"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"cmp","","",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"ordering"}}],[11,"hash","","",6,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",6,{"inputs":[],"output":{"name":"groupflags"}}],[11,"all","","Returns the set containing all flags.",6,{"inputs":[],"output":{"name":"groupflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",6,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",6,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",6,{"inputs":[{"name":"u32"}],"output":{"name":"groupflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"groupflags"}}],[11,"bitor_assign","","Adds the set of flags.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"groupflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"groupflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":{"name":"groupflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",6,{"inputs":[{"name":"self"},{"name":"groupflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",6,{"inputs":[{"name":"self"}],"output":{"name":"groupflags"}}],[11,"extend","","",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",6,{"inputs":[{"name":"t"}],"output":{"name":"groupflags"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"sections"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",7,{"inputs":[{"name":"headerrepr"},{"name":"u32"},{"name":"u32"}],"output":{"name":"sections"}}],[11,"next","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"strtable"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",8,null],[11,"at_index","","Returns the string at a given index in the string table, if there is one.",8,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"deref","","",8,null],[11,"into_iter","","",8,null],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"strings"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",9,null],[0,"file","elf","ELF file header",null,null],[3,"HeaderRepr","elf::file","Raw representation of an ELF file header.",null,null],[12,"ident","","the ELF file identifier",10,null],[12,"machine","","",10,null],[12,"flags","","",10,null],[12,"header_size","","",10,null],[12,"ph_entry_size","","",10,null],[12,"ph_count","","",10,null],[12,"sh_entry_size","","",10,null],[12,"sh_count","","",10,null],[3,"Ident","","ELF identifier (`e_ident` in the ELF standard)",null,null],[12,"magic","","ELF magic numbers. Must be equal to the [ELF magic], `[0x7, E, L, F]`.",11,null],[12,"class","","ELF file class (32- or 64-bit)",11,null],[12,"encoding","","ELF data encoding (big- or little-endian)",11,null],[12,"version","","ELF file version",11,null],[12,"abi","","What [operating system ABI] this file was compiled for.",11,null],[12,"abi_version","","ABI version (often this is just padding)",11,null],[4,"Class","","Identifies the class of the ELF file",null,null],[13,"None","","Invalid ELF class file (`ELFCLASSNONE` in the standard)",12,null],[13,"Elf32","","32-bit ELF file (`ELFCLASS32` in the standard)",12,null],[13,"Elf64","","64-bit ELF file (`ELFCLASS64` in the standard)",12,null],[4,"DataEncoding","","Identifies the data encoding of the ELF file",null,null],[13,"None","","Invalid data encoding (`ELFDATANONE` in the standard)",13,null],[13,"LittleEndian","","Twos-complement little-endian data encoding (`ELFDATA2LSB` in the standard)",13,null],[13,"BigEndian","","Twos-complement big-endian data encoding (`ELFDATA2MSB` in the standard)",13,null],[4,"OsAbi","","Operating system ABI",null,null],[13,"SystemV","","Ox00 also represents \"none\"",14,null],[13,"HpUx","","",14,null],[13,"NetBsd","","",14,null],[13,"Linux","","",14,null],[13,"Solaris","","",14,null],[13,"Aix","","",14,null],[13,"Irix","","",14,null],[13,"FreeBsd","","",14,null],[13,"OpenBsd","","",14,null],[13,"OpenVms","","",14,null],[4,"Version","","Identifies the version of the ELF file",null,null],[13,"None","","",15,null],[13,"Current","","",15,null],[4,"Type","","",null,null],[13,"None","","",16,null],[13,"Relocatable","","",16,null],[13,"Executable","","",16,null],[13,"SharedObject","","",16,null],[13,"Core","","",16,null],[13,"Other","","",16,null],[4,"Machine","","",null,null],[13,"None","","",17,null],[13,"Sparc","","",17,null],[13,"X86","","",17,null],[13,"Mips","","",17,null],[13,"PowerPc","","",17,null],[13,"Arm","","",17,null],[13,"SuperH","","",17,null],[13,"Ia64","","",17,null],[13,"X86_64","","",17,null],[13,"AArch64","","",17,null],[6,"Magic","","Type of header magic",null,null],[17,"MAGIC","","ELF header magic",null,null],[8,"Header","","Trait representing an ELF File Header.",null,null],[16,"Word","","",18,null],[10,"from_slice","","Attempt to extract an ELF file header from a slice of bytes.",18,null],[10,"parse_section","","Attempt to extract a section header from a slice of bytes. TODO: can/should the index be `usize`?",18,null],[11,"sh_range","","",18,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"ph_range","","",18,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"section_index","","Calculate the index for a [section header]",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"range"}}],[11,"program_header_index","","Calculate the index for a program header",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"range"}}],[10,"ident","","",18,{"inputs":[{"name":"self"}],"output":{"name":"ident"}}],[10,"get_type","","",18,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[10,"machine","","",18,{"inputs":[{"name":"self"}],"output":{"name":"machine"}}],[10,"entry_point","","Offset of the program entry point",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"ph_offset","","Offset of the start of program headers",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"ph_count","","Number of program headers.",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"ph_entry_size","","Size of a program header.",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"sh_offset","","Offset of the start of [section header]s.",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"sh_count","","Number of [section header]s.",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"sh_entry_size","","Size of a [section header].",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"flags","","TODO: can this return the flags type?",18,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"sh_str_idx","","Index of the section header [string table].",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"headerrepr"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_slice","","Attempt to extract an ELF file header from a slice of bytes.",10,null],[11,"parse_section","","Attempt to extract a [section header] from a slice of bytes.",10,null],[11,"get_type","","",10,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"sh_offset","","Index for the start of [section header]s. [section header]: ../section/struct.Header.html",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"sh_entry_size","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"sh_count","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ph_offset","","Index for the start of program headers",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ph_entry_size","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ph_count","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"entry_point","","Index for the program entry point",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"sh_str_idx","","Index of the section header [string table] [string table]: ../section/struct.StrTable.html",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"flags","","",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"ident","","",10,{"inputs":[{"name":"self"}],"output":{"name":"ident"}}],[11,"machine","","",10,{"inputs":[{"name":"self"}],"output":{"name":"machine"}}],[11,"from_slice","","Attempt to extract an ELF file header from a slice of bytes.",10,null],[11,"parse_section","","Attempt to extract a [section header] from a slice of bytes.",10,null],[11,"get_type","","",10,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"sh_offset","","Index for the start of [section header]s. [section header]: ../section/struct.Header.html",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"sh_entry_size","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"sh_count","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ph_offset","","Index for the start of program headers",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ph_entry_size","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ph_count","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"entry_point","","Index for the program entry point",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"sh_str_idx","","Index of the section header [string table] [string table]: ../section/struct.StrTable.html",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"flags","","",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"ident","","",10,{"inputs":[{"name":"self"}],"output":{"name":"ident"}}],[11,"machine","","",10,{"inputs":[{"name":"self"}],"output":{"name":"machine"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"ident"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"check_magic","","",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_valid","","Returns true if the identifier section identifies a valid ELF file.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"class"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"class"}],"output":{"name":"bool"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_valid","","Returns true if the class field for this file is valid.",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"dataencoding"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"dataencoding"}],"output":{"name":"bool"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_valid","","Returns true if the data encoding field for this file is valid.",13,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"osabi"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"version"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"machine"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"machine"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"program","elf","",null,null],[3,"Flags","elf::program","",null,null],[3,"HeaderRepr64","","A 64-bit ELF Program Header",null,null],[12,"ty","","",19,null],[12,"flags","","",19,null],[12,"offset","","",19,null],[12,"vaddr","","",19,null],[12,"paddr","","",19,null],[12,"file_size","","",19,null],[12,"mem_size","","",19,null],[12,"align","","",19,null],[3,"HeaderRepr32","","A 32-bit ELF Program Header",null,null],[12,"ty","","",20,null],[12,"offset","","",20,null],[12,"vaddr","","",20,null],[12,"paddr","","",20,null],[12,"file_size","","",20,null],[12,"mem_size","","",20,null],[12,"flags","","",20,null],[12,"align","","",20,null],[4,"Type","","The type field of an ELF program header",null,null],[13,"Null","","`PT_NULL`: Program header table entry unused",21,null],[13,"Loadable","","`PT_LOAD`: Loadable program segment",21,null],[13,"Dynamic","","`PT_DYNAMIC`: Dynamic linking information",21,null],[13,"Interpreter","","`PT_INTERP`: Program interpreter",21,null],[13,"Note","","`PT_NOTE`: Auxiliary information",21,null],[13,"ShLib","","`PT_SHLIB`",21,null],[13,"HeaderTable","","`PT_PHDR`: Program Header table",21,null],[13,"ThreadLocal","","`PT_TLS`: Thread-local storage",21,null],[13,"GnuEhFrame","","GCC `.eh_frame_hdr` segment",21,null],[13,"GnuStack","","Indicates stack executability",21,null],[13,"GnuRelRo","","Read-only after relocation",21,null],[17,"NONE","","",null,null],[17,"EXECUTABLE","","",null,null],[17,"WRITABLE","","",null,null],[17,"READABLE","","",null,null],[8,"Header","","Trait representing an ELF Program Header.",null,null],[16,"Word","","",22,null],[10,"ty","","Returns the type of this program header.",22,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[10,"offset","","Returns this segment's start offset from the beginning of the binary.",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"vaddr","","Returns the virtual address of the first byte in this segment.",22,null],[10,"paddr","","Returns the physical address of the first byte in this segment.",22,null],[10,"file_size","","Returns the number of bytes in the file image of the segment.",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"mem_size","","Returns the number of bytes in the memory image of the segment.",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"flags","","Returns the [flags] for this segment.",22,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[10,"align","","",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"partial_cmp","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"option"}}],[11,"lt","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"le","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"gt","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"ge","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"cmp","","",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"ordering"}}],[11,"hash","","",23,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",23,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",23,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",23,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",23,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",23,{"inputs":[{"name":"u32"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitor_assign","","Adds the set of flags.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitxor_assign","","Toggles the set of flags.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":{"name":"flags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",23,{"inputs":[{"name":"self"},{"name":"flags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",23,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"extend","","",23,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",23,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"headerrepr64"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"ty","","",19,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"flags","","",19,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"offset","","",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"vaddr","","",19,null],[11,"paddr","","",19,null],[11,"file_size","","",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"mem_size","","",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"align","","",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"headerrepr32"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"ty","","",20,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"flags","","",20,{"inputs":[{"name":"self"}],"output":{"name":"flags"}}],[11,"offset","","",20,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"vaddr","","",20,null],[11,"paddr","","",20,null],[11,"file_size","","",20,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"mem_size","","",20,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"align","","",20,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[6,"Section","elf","An ELF section header.",null,null],[6,"ProgramHeader","","",null,null],[6,"FileHeader","","An ELF header file.",null,null],[6,"ElfResult","","TODO: should ELF have its own error type?",null,null],[8,"ElfWord","","",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"sh_str_table","","Returns the section header [string table].",0,{"inputs":[{"name":"self"}],"output":{"name":"strtable"}}],[11,"try_from","","",0,null]],"paths":[[3,"Image"],[4,"Contents"],[4,"Type"],[8,"Header"],[3,"HeaderRepr"],[3,"Flags"],[3,"GroupFlags"],[3,"Sections"],[3,"StrTable"],[3,"Strings"],[3,"HeaderRepr"],[3,"Ident"],[4,"Class"],[4,"DataEncoding"],[4,"OsAbi"],[4,"Version"],[4,"Type"],[4,"Machine"],[8,"Header"],[3,"HeaderRepr64"],[3,"HeaderRepr32"],[4,"Type"],[8,"Header"],[3,"Flags"]]};
searchIndex["lazy_static"] = {"doc":"A macro for declaring lazily evaluated statics.","items":[[5,"initialize","lazy_static","Takes a shared reference to a lazy static and initializes it if it has not been already.",null,{"inputs":[{"name":"t"}],"output":null}],[8,"LazyStatic","","Support trait for enabling a few common operation on lazy static values.",null,null],[14,"lazy_static","","",null,null]],"paths":[]};
searchIndex["log"] = {"doc":"A lightweight logging facade.","items":[[3,"LogRecord","log","The \"payload\" of a log message. This structure is primarily used as a parameter in the [`log`] method of the [`Log`] trait.",null,null],[3,"LogMetadata","","Metadata about a log message.",null,null],[3,"LogLocation","","The location of a log message.",null,null],[3,"MaxLogLevelFilter","","A token providing read and write access to the global maximum log level filter.",null,null],[3,"SetLoggerError","","The type returned by `set_logger` if `set_logger` has already been called.",null,null],[3,"ShutdownLoggerError","","The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has already been called or if `set_logger_raw` has not been called yet.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework.",null,null],[13,"Error","","The \"error\" level.",0,null],[13,"Warn","","The \"warn\" level.",0,null],[13,"Info","","The \"info\" level.",0,null],[13,"Debug","","The \"debug\" level.",0,null],[13,"Trace","","The \"trace\" level.",0,null],[4,"LogLevelFilter","","An enum representing the available verbosity level filters of the logging framework.",null,null],[13,"Off","","A level lower than all log levels.",1,null],[13,"Error","","Corresponds to the `Error` log level.",1,null],[13,"Warn","","Corresponds to the `Warn` log level.",1,null],[13,"Info","","Corresponds to the `Info` log level.",1,null],[13,"Debug","","Corresponds to the `Debug` log level.",1,null],[13,"Trace","","Corresponds to the `Trace` log level.",1,null],[5,"max_log_level","","Returns the current maximum log level.",null,{"inputs":[],"output":{"name":"loglevelfilter"}}],[5,"set_logger_raw","","Sets the global logger from a raw pointer.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"shutdown_logger_raw","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[8,"Log","","A trait encapsulating the operations required of a logger",null,null],[10,"enabled","","Determines if a log message with the specified metadata would be logged.",2,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[10,"log","","Logs the `LogRecord`.",2,{"inputs":[{"name":"self"},{"name":"logrecord"}],"output":null}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"loglevel"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"loglevel"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"loglevelfilter"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"loglevel"}],"output":{"name":"option"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"loglevelfilter"}],"output":{"name":"option"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"loglevel"}],"output":{"name":"ordering"}}],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"max","","Returns the most verbose logging level.",0,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",0,{"inputs":[{"name":"self"}],"output":{"name":"loglevelfilter"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"loglevelfilter"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"loglevelfilter"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"loglevel"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"loglevelfilter"}],"output":{"name":"option"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"loglevel"}],"output":{"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"loglevelfilter"}],"output":{"name":"ordering"}}],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"max","","Returns the most verbose logging level filter.",1,{"inputs":[],"output":{"name":"loglevelfilter"}}],[11,"to_log_level","","Converts `self` to the equivalent `LogLevel`.",1,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"args","","The message body.",3,{"inputs":[{"name":"self"}],"output":{"name":"arguments"}}],[11,"metadata","","Metadata about the log directive.",3,{"inputs":[{"name":"self"}],"output":{"name":"logmetadata"}}],[11,"location","","The location of the log directive.",3,{"inputs":[{"name":"self"}],"output":{"name":"loglocation"}}],[11,"level","","The verbosity level of the message.",3,{"inputs":[{"name":"self"}],"output":{"name":"loglevel"}}],[11,"target","","The name of the target of the directive.",3,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[11,"cmp","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"option"}}],[11,"lt","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[11,"le","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[11,"gt","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[11,"ge","","",4,{"inputs":[{"name":"self"},{"name":"logmetadata"}],"output":{"name":"bool"}}],[11,"hash","","",4,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"level","","The verbosity level of the message.",4,{"inputs":[{"name":"self"}],"output":{"name":"loglevel"}}],[11,"target","","The name of the target of the directive.",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"loglocation"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"bool"}}],[11,"cmp","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"option"}}],[11,"lt","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"bool"}}],[11,"le","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"bool"}}],[11,"gt","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"bool"}}],[11,"ge","","",5,{"inputs":[{"name":"self"},{"name":"loglocation"}],"output":{"name":"bool"}}],[11,"hash","","",5,null],[11,"module_path","","The module path of the message.",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"file","","The source file containing the message.",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"line","","The line containing the message.",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"get","","Gets the current maximum log level filter.",6,{"inputs":[{"name":"self"}],"output":{"name":"loglevelfilter"}}],[11,"set","","Sets the maximum log level.",6,{"inputs":[{"name":"self"},{"name":"loglevelfilter"}],"output":null}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[14,"log","","The standard logging macro.",null,null],[14,"error","","Logs a message at the error level.",null,null],[14,"warn","","Logs a message at the warn level.",null,null],[14,"info","","Logs a message at the info level.",null,null],[14,"debug","","Logs a message at the debug level.",null,null],[14,"trace","","Logs a message at the trace level.",null,null],[14,"log_enabled","","Determines if a message logged at the specified level in that module will be logged.",null,null]],"paths":[[4,"LogLevel"],[4,"LogLevelFilter"],[8,"Log"],[3,"LogRecord"],[3,"LogMetadata"],[3,"LogLocation"],[3,"MaxLogLevelFilter"],[3,"SetLoggerError"],[3,"ShutdownLoggerError"]]};
searchIndex["macro_attr"] = {"doc":"This crate provides the `macro_attr!` macro that enables the use of custom, macro-based attributes and derivations.  Supercedes the `custom_derive` crate.","items":[[14,"macro_attr","macro_attr","When given an item definition, including its attributes, this macro parses said attributes and dispatches any attributes or derivations suffixed with `!` to user-defined macros.  This allows multiple macros to process the same item.",null,null],[14,"macro_attr_callback","","This macro invokes a \"callback\" macro, merging arguments together.",null,null]],"paths":[]};
searchIndex["memory"] = {"doc":"Kernel memory management.","items":[[3,"PAddr","memory","A physical (linear) memory address is a 64-bit unsigned integer",null,null],[3,"VAddr","","A virtual address is a machine-sized unsigned integer",null,null],[3,"PhysicalPage","","A frame (physical page)",null,null],[12,"number","","",0,null],[3,"VirtualPage","","A virtual page",null,null],[12,"number","","",1,null],[3,"RangeIter","","An iterator over a range of pages",null,null],[0,"macros","","Macros to make our custom address types require a lot less repetitive code.",null,null],[0,"arch","","",null,null],[3,"PAddr","memory::arch","A physical (linear) memory address is a 64-bit unsigned integer",null,null],[3,"PhysicalPage","","A frame (physical page)",null,null],[12,"number","","",0,null],[11,"clone","memory","",2,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"cmp","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"ordering"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into","","",2,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"from","","",2,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"from","","",2,null],[11,"from","","",2,null],[11,"deref","","",2,null],[11,"as_mut_ptr","","",2,null],[11,"as_ptr","","",2,null],[11,"new","","",2,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"add","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"add","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"add","","",2,null],[11,"add","","",2,null],[11,"sub","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"sub","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"sub","","",2,null],[11,"sub","","",2,null],[11,"div","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"div","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"div","","",2,null],[11,"div","","",2,null],[11,"mul","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"mul","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"shl","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"shl","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"shl","","",2,null],[11,"shl","","",2,null],[11,"shr","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"shr","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"shr","","",2,null],[11,"shr","","",2,null],[11,"rem","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"rem","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"rem","","",2,null],[11,"rem","","",2,null],[11,"bitand","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"bitand","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"bitand","","",2,null],[11,"bitand","","",2,null],[11,"bitor","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"bitor","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"bitor","","",2,null],[11,"bitor","","",2,null],[11,"bitxor","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":{"name":"paddr"}}],[11,"bitxor","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"paddr"}}],[11,"bitxor","","",2,null],[11,"bitxor","","",2,null],[11,"add_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"add_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"sub_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"sub_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"div_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"div_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"mul_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"mul_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"shl_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"shl_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"shr_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"shr_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"rem_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"rem_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"bitand_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"bitand_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"bitor_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"bitor_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"bitxor_assign","","",2,{"inputs":[{"name":"self"},{"name":"paddr"}],"output":null}],[11,"bitxor_assign","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"option"}}],[11,"align_down","","",2,null],[11,"align_up","","",2,null],[11,"is_page_aligned","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"physicalpage"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"ordering"}}],[11,"containing","","Create a new `Page` containing the given address.",0,{"inputs":[{"name":"paddr"}],"output":{"name":"self"}}],[11,"base","","Return the start address of this page",0,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"end_address","","Return the end address of this page",0,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"number","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"step","","",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"steps_between","","",0,{"inputs":[{"name":"physicalpage"},{"name":"physicalpage"},{"name":"physicalpage"}],"output":{"name":"option"}}],[11,"steps_between_by_one","","",0,{"inputs":[{"name":"physicalpage"},{"name":"physicalpage"}],"output":{"name":"option"}}],[11,"sub_one","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"add_one","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"replace_one","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"replace_zero","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_negative","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"from","","",0,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"add","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"add","","",0,null],[11,"add","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"sub","","",0,null],[11,"sub","","",0,null],[11,"sub","","",0,null],[11,"div","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"div","","",0,null],[11,"div","","",0,null],[11,"div","","",0,null],[11,"mul","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"mul","","",0,null],[11,"mul","","",0,null],[11,"mul","","",0,null],[11,"shl","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"shl","","",0,null],[11,"shl","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"shr","","",0,null],[11,"shr","","",0,null],[11,"shr","","",0,null],[11,"rem","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"rem","","",0,null],[11,"rem","","",0,null],[11,"rem","","",0,null],[11,"bitand","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"bitand","","",0,null],[11,"bitand","","",0,null],[11,"bitand","","",0,null],[11,"bitor","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"bitor","","",0,null],[11,"bitor","","",0,null],[11,"bitor","","",0,null],[11,"bitxor","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":{"name":"self"}}],[11,"bitxor","","",0,null],[11,"bitxor","","",0,null],[11,"bitxor","","",0,null],[11,"add_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"add_assign","","",0,null],[11,"sub_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"sub_assign","","",0,null],[11,"div_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"div_assign","","",0,null],[11,"mul_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"mul_assign","","",0,null],[11,"shl_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"shl_assign","","",0,null],[11,"shr_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"shr_assign","","",0,null],[11,"rem_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"rem_assign","","",0,null],[11,"bitand_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"bitand_assign","","",0,null],[11,"bitor_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"bitor_assign","","",0,null],[11,"bitxor_assign","","",0,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"bitxor_assign","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"add","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"sub","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"add_assign","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"sub_assign","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"base_addr","","Returns the physical address where this frame starts.",0,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"containing_addr","","Returns a new frame containing `addr`",0,{"inputs":[{"name":"paddr"}],"output":{"name":"physicalpage"}}],[11,"as_ptr","","Convert the frame into a raw pointer to the frame's base address",0,null],[11,"as_mut_ptr","","Convert the frame into a raw mutable pointer to the frame's base address",0,null],[17,"PAGE_SHIFT","memory::arch","",null,null],[17,"PAGE_SIZE","","The size of a page (4KiB), in bytes",null,null],[17,"LARGE_PAGE_SIZE","","The size of a large page (2MiB) in bytes",null,null],[17,"HUGE_PAGE_SIZE","","The size of a huge page (2GiB) in bytes",null,null],[6,"PageRange","memory","",null,null],[6,"FrameRange","","",null,null],[17,"PAGE_SHIFT","","",null,null],[17,"PAGE_SIZE","","The size of a page (4KiB), in bytes",null,null],[8,"Addr","","Trait representing an address, whether physical or virtual.",null,null],[16,"Repr","","",3,null],[10,"align_down","","",3,null],[10,"align_up","","",3,null],[10,"is_page_aligned","","Returns true if this address is aligned on a page boundary.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Page","","Trait for a page. These can be virtual pages or physical frames.",null,null],[16,"Address","","The type of address used to address this `Page`.",4,null],[10,"containing","","Returns a new `Page` containing the given `Address`.",4,null],[10,"base","","Returns the base `Address` where this page starts.",4,null],[10,"end_address","","Returns the end `Address` of this `Page`.",4,null],[11,"range_of","","Returns a `PageRange` of this `Page` and the next `n` pages.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"range"}}],[11,"range_until","","Returns a `PageRange` on the frames from this frame until the end frame",4,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"range"}}],[10,"number","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"MemRange","","",null,null],[10,"length","","Returns the number of `Page`s in this ranage",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"drop_front","","Remove `n` pages from the beginning of this `PageRange`",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[10,"drop_back","","Remove `n` pages from the end of this `PageRange`",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[10,"add_front","","Add `n` pages at the front of this `PageRange`",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[10,"add_back","","Add `n` pages at the back of this `PageRange`",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"vaddr"}}],[11,"cmp","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"ordering"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into","","",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"from","","",6,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from","","",6,null],[11,"from","","",6,null],[11,"deref","","",6,null],[11,"as_mut_ptr","","",6,null],[11,"as_ptr","","",6,null],[11,"new","","",6,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"add","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"add","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"add","","",6,null],[11,"add","","",6,null],[11,"sub","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"sub","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"sub","","",6,null],[11,"sub","","",6,null],[11,"div","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"div","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"div","","",6,null],[11,"div","","",6,null],[11,"mul","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"mul","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"mul","","",6,null],[11,"mul","","",6,null],[11,"shl","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"shl","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"shl","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"shr","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"shr","","",6,null],[11,"shr","","",6,null],[11,"rem","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"rem","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"rem","","",6,null],[11,"rem","","",6,null],[11,"bitand","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"bitand","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"bitand","","",6,null],[11,"bitand","","",6,null],[11,"bitor","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"bitor","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"bitor","","",6,null],[11,"bitor","","",6,null],[11,"bitxor","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"vaddr"}}],[11,"bitxor","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vaddr"}}],[11,"bitxor","","",6,null],[11,"bitxor","","",6,null],[11,"add_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"add_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"sub_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"sub_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"div_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"div_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"mul_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"mul_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"shl_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"shl_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"shr_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"shr_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"rem_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"rem_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"bitand_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"bitand_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"bitor_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"bitor_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"bitxor_assign","","",6,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":null}],[11,"bitxor_assign","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"align_down","","",6,null],[11,"align_up","","",6,null],[11,"is_page_aligned","","",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"from_ptr","","Convert this virtual address to a pointer",6,null],[11,"from_usize","","Convert a `usize` to a virtual address",6,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"as_usize","","Convert this virtual address to a `usize`.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"pml4_index","","Calculate the index in the PML4 table corresponding to this address.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"pdpt_index","","Calculate the index in the PDPT table corresponding to this address.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"pd_index","","Calculate the index in the PD table corresponding to this address.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"pt_index","","Calculate the index in the PT table corresponding to this address.",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"virtualpage"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"ordering"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"containing","","Create a new `Page` containing the given address.",1,{"inputs":[{"name":"vaddr"}],"output":{"name":"self"}}],[11,"base","","Return the start address of this page",1,{"inputs":[{"name":"self"}],"output":{"name":"vaddr"}}],[11,"end_address","","Return the end address of this page",1,{"inputs":[{"name":"self"}],"output":{"name":"vaddr"}}],[11,"number","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"step","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"steps_between","","",1,{"inputs":[{"name":"virtualpage"},{"name":"virtualpage"},{"name":"virtualpage"}],"output":{"name":"option"}}],[11,"steps_between_by_one","","",1,{"inputs":[{"name":"virtualpage"},{"name":"virtualpage"}],"output":{"name":"option"}}],[11,"sub_one","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"add_one","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"replace_one","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"replace_zero","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_negative","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"from","","",1,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"add","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"add","","",1,null],[11,"add","","",1,null],[11,"add","","",1,null],[11,"sub","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"div","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"div","","",1,null],[11,"div","","",1,null],[11,"div","","",1,null],[11,"mul","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"shl","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"shl","","",1,null],[11,"shl","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"shr","","",1,null],[11,"shr","","",1,null],[11,"shr","","",1,null],[11,"rem","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"rem","","",1,null],[11,"rem","","",1,null],[11,"rem","","",1,null],[11,"bitand","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"bitand","","",1,null],[11,"bitand","","",1,null],[11,"bitand","","",1,null],[11,"bitor","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"bitor","","",1,null],[11,"bitor","","",1,null],[11,"bitor","","",1,null],[11,"bitxor","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"self"}}],[11,"bitxor","","",1,null],[11,"bitxor","","",1,null],[11,"bitxor","","",1,null],[11,"add_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"add_assign","","",1,null],[11,"sub_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"sub_assign","","",1,null],[11,"div_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"div_assign","","",1,null],[11,"mul_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"mul_assign","","",1,null],[11,"shl_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"shl_assign","","",1,null],[11,"shr_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"shr_assign","","",1,null],[11,"rem_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"rem_assign","","",1,null],[11,"bitand_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"bitand_assign","","",1,null],[11,"bitor_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"bitor_assign","","",1,null],[11,"bitxor_assign","","",1,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":null}],[11,"bitxor_assign","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[14,"Addr","","",null,null]],"paths":[[3,"PhysicalPage"],[3,"VirtualPage"],[3,"PAddr"],[8,"Addr"],[8,"Page"],[8,"MemRange"],[3,"VAddr"],[3,"RangeIter"]]};
searchIndex["nodrop"] = {"doc":"","items":[[3,"NoDrop","nodrop","A type holding T that will not call its destructor on drop",null,null],[11,"new","","Create a new NoDrop.",0,{"inputs":[{"name":"t"}],"output":{"name":"nodrop"}}],[11,"into_inner","","Extract the inner value.",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",0,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}]],"paths":[[3,"NoDrop"]]};
searchIndex["odds"] = {"doc":"Odds and ends — collection miscellania.","items":[[3,"Fix","odds","Fixpoint combinator for rust closures, generalized over the return type.",null,null],[12,"0","","",0,null],[5,"fix","","Fixpoint combinator for rust closures, generalized over the return type.",null,{"inputs":[{"name":"t"},{"name":"f"}],"output":{"name":"r"}}],[5,"ref_eq","","Compare if a and b are equal as pointers.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"ptr_eq","","Compare if a and b are equal pointers.",null,null],[5,"raw_byte_repr","","Safe to use with any wholly initialized memory `ptr`",null,null],[5,"get_unchecked","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"get_unchecked_mut","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"debug_assert_unreachable","","Act as `debug_assert!` in debug mode, asserting that this point is not reached.",null,null],[5,"slice_unchecked","","Check slicing bounds in debug mode, otherwise just act as an unchecked slice call.",null,null],[5,"slice_unchecked_mut","","Check slicing bounds in debug mode, otherwise just act as an unchecked slice call.",null,null],[5,"ref_slice","","Create a length 1 slice out of a reference",null,null],[5,"ref_slice_mut","","Create a length 1 mutable slice out of a reference",null,null],[11,"call","","",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"r"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[0,"char","","Extra functions for `char`",null,null],[3,"EncodeUtf8Error","odds::char","Placeholder",null,null],[5,"encode_utf8","","Encode a char into buf using UTF-8.",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"encodeutf8error"}}],[0,"string","odds","Extensions to `&str` and `String`",null,null],[3,"Prefixes","odds::string","Iterator of all non-empty prefixes",null,null],[3,"Suffixes","","Iterator of all non-empty suffixes",null,null],[3,"Substrings","","Iterator of all non-empty substrings",null,null],[3,"CharChunks","","An iterator that splits the string in substrings of each `n` `char` per substring. The last item will contain the remainder if `n` does not divide the char length of the string evenly.",null,null],[3,"CharWindows","","An iterator that produces substrings of each `n` `char` per substring in a sliding window that advances one char at a time.",null,null],[3,"CharStr","","A single-char string.",null,null],[8,"StrExt","","Extra methods for `str`",null,null],[10,"prefixes","","All non-empty prefixes",2,{"inputs":[{"name":"self"}],"output":{"name":"prefixes"}}],[10,"suffixes","","All non-empty suffixes",2,{"inputs":[{"name":"self"}],"output":{"name":"suffixes"}}],[10,"substrings","","Produce all non-empty substrings",2,{"inputs":[{"name":"self"}],"output":{"name":"substrings"}}],[10,"is_acceptable_index","","Return `true` if `index` is acceptable for slicing the string.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[8,"StrSlice","","Extension trait for `str` for string slicing without panicking",null,null],[10,"get_slice","","Return a slice of the string, if it is in bounds /and on character boundaries/, otherwise return `None`",3,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"option"}}],[8,"StrChunksWindows","","Extension traits for the `char_chunks` and `char_windows` methods",null,null],[10,"char_chunks","","Return an iterator that splits the string in substrings of each `n` `char` per substring. The last item will contain the remainder if `n` does not divide the char length of the string evenly.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"charchunks"}}],[10,"char_windows","","Return an iterator that produces substrings of each `n` `char` per substring in a sliding window that advances one char at a time.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"charwindows"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"prefixes"}}],[11,"next","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"suffixes"}}],[11,"next","","",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"substrings"}}],[11,"next","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"charchunks"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"charwindows"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"charstr"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new string from `c`.",10,{"inputs":[{"name":"char"}],"output":{"name":"charstr"}}],[11,"deref","","",10,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"slice","odds","Extra functions for slices",null,null],[3,"MendSlices","odds::slice","An iterator adaptor that glues together adjacent contiguous slices.",null,null],[3,"RevSlice","","A reversed view of a slice.",null,null],[5,"shared_prefix","","Return the end index of the longest shared (equal) prefix of `a` and `b`.",null,null],[5,"rotate_left","","Rotate `steps` towards lower indices.",null,null],[5,"split_aligned_for","","Split the input slice into three chunks, so that the middle chunk is a slice of a larger \"block size\" (for example T could be u64) that is correctly aligned for `T`.",null,null],[0,"unalign","","",null,null],[3,"UnalignedIter","odds::slice::unalign","An iterator of `T` (by value) where each value read using an unaligned load.",null,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"from_raw_parts","","Create an `UnalignedIter` from `ptr` and `end`, which must be spaced an whole number of `T` offsets apart.",11,null],[11,"from_slice","","Create an `UnalignedIter` out of the slice of data, which iterates first in blocks of `T` (unaligned loads), and then leaves a tail of the remaining bytes.",11,null],[11,"tail","","Return a byte iterator of the remaining tail of the iterator; this can be called at any time, but in particular when the iterator has returned None.",11,{"inputs":[{"name":"self"}],"output":{"name":"slicecopyiter"}}],[11,"has_tail","","Return `true` if the tail is not empty.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"peek_next","","Return the next iterator element, without stepping the iterator.",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"iter","odds::slice","",null,null],[3,"SliceCopyIter","odds::slice::iter","Slice (contiguous data) iterator.",null,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","",12,null],[11,"into_raw","","Return the start, end pointer of the iterator",12,null],[11,"next","","",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",12,null],[11,"count","","",12,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"from","","",12,null],[11,"default","","Create an empty `SliceCopyIter`.",12,{"inputs":[],"output":{"name":"self"}}],[8,"SliceFind","odds::slice","Element-finding methods for slices",null,null],[16,"Item","","",13,null],[10,"find","","Linear search for the first occurrence  `elt` in the slice.",13,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[10,"rfind","","Linear search for the last occurrence  `elt` in the slice.",13,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[8,"SliceFindSplit","","Element-finding methods for slices",null,null],[16,"Item","","",14,null],[10,"find_split","","Linear search for the first occurrence  `elt` in the slice.",14,null],[10,"rfind_split","","Linear search for the last occurrence  `elt` in the slice.",14,null],[10,"find_split_mut","","Linear search for the first occurrence  `elt` in the slice.",14,null],[10,"rfind_split_mut","","Linear search for the last occurrence  `elt` in the slice.",14,null],[8,"SliceIterExt","","Extra iterator adaptors for iterators of slice elements.",null,null],[11,"mend_slices","","Return an iterator adaptor that joins together adjacent slices if possible.",15,{"inputs":[{"name":"self"}],"output":{"name":"mendslices"}}],[8,"MendSlice","","A trait for items that can maybe be joined together.",null,null],[8,"Pod","","\"plain old data\": Types that we can stick arbitrary bit patterns into, and thus use them as blocks in `split_aligned_for` or in `UnalignedIter`.",null,null],[11,"find","","",16,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[11,"rfind","","",16,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"option"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"new","","Create a new `MendSlices`.",17,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",17,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"len","","Return the length of the slice.",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get","","Get element at index `i`.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_mut","","Get element at index `i`.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"inner_ref","","",16,null],[11,"inner_mut","","",16,null],[11,"iter","","Return a by-reference iterator",16,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"iter_mut","","Return a by-mutable-reference iterator",16,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"split_at","","",16,null],[11,"split_at_mut","","",16,null],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"revslice"}],"output":{"name":"bool"}}],[11,"eq","","",16,null],[11,"hash","","",16,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"index","","",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"index_mut","","",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"index","","",16,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"revslice"}}],[11,"index_mut","","",16,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"revslice"}}],[0,"stride","odds","Slice iterator with custom step size",null,null],[3,"Stride","odds::stride","(the stride) skipped per iteration.",null,null],[3,"StrideMut","","The mutable equivalent of Stride.",null,null],[11,"from_ptr_len","","Create a Stride iterator from a raw pointer.",18,null],[11,"from_ptr_len","","Create a StrideMut iterator from a raw pointer.",19,null],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",18,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",18,{"inputs":[{"name":"stride"},{"name":"isize"}],"output":{"name":"stride"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride, in effect reversing the iterator.",18,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Return the number of elements in the iterator.",18,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get","","Return a reference to the element of a stride at the given index, or None if the index is out of bounds.",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",18,null],[11,"next_back","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"index","","Return a reference to the element at a given index.",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"a"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",19,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",19,{"inputs":[{"name":"stridemut"},{"name":"isize"}],"output":{"name":"stridemut"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride, in effect reversing the iterator.",19,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Return the number of elements in the iterator.",19,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get","","Return a reference to the element of a stride at the given index, or None if the index is out of bounds.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","","",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",19,null],[11,"next_back","","",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"index","","Return a reference to the element at a given index.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"a"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"stride"}}],[11,"get_mut","","Return a mutable reference to the element of a stride at the given index, or None if the index is out of bounds.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"index_mut","","Return a mutable reference to the element at a given index.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"a"}}],[0,"prelude","odds","prelude of often used traits and functions",null,null],[8,"IndexRange","","IndexRange is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"end","","End index (exclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"start","","Start index (inclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"end","","End index (exclusive)",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[3,"Fix"],[3,"EncodeUtf8Error"],[8,"StrExt"],[8,"StrSlice"],[8,"StrChunksWindows"],[3,"Prefixes"],[3,"Suffixes"],[3,"Substrings"],[3,"CharChunks"],[3,"CharWindows"],[3,"CharStr"],[3,"UnalignedIter"],[3,"SliceCopyIter"],[8,"SliceFind"],[8,"SliceFindSplit"],[8,"SliceIterExt"],[3,"RevSlice"],[3,"MendSlices"],[3,"Stride"],[3,"StrideMut"],[8,"IndexRange"]]};
searchIndex["once"] = {"doc":"","items":[[14,"assert_has_not_been_called","once","This macro can be used to ensure that a function is called only once. It panics if the function is called a second time.",null,null]],"paths":[]};
searchIndex["paging"] = {"doc":"SOS Paging","items":[[4,"MapErr","paging","",null,null],[13,"Alloc","","",0,null],[12,"message","paging::MapErr","",0,null],[12,"page","","",0,null],[12,"cause","","",0,null],[13,"Other","paging","",0,null],[12,"message","paging::MapErr","",0,null],[12,"page","","",0,null],[12,"cause","","",0,null],[13,"TableNotFound","paging","",0,null],[12,"message","paging::MapErr","",0,null],[12,"page","","",0,null],[12,"what","","",0,null],[13,"AlreadyInUse","paging","",0,null],[12,"message","paging::MapErr","",0,null],[12,"page","","",0,null],[12,"frame","","",0,null],[13,"NoPage","paging","",0,null],[12,"message","paging::MapErr","",0,null],[12,"cause","","",0,null],[5,"kernel_remap","paging","Remaps the kernel using 4KiB pages.",null,{"inputs":[{"name":"initparams"},{"name":"a"}],"output":{"name":"mapresult"}}],[5,"test_paging","","",null,{"inputs":[{"name":"a"}],"output":{"name":"mapresult"}}],[0,"arch","","",null,null],[3,"ActivePageTable","paging::arch","",null,null],[3,"ActivePML4","","Struct representing the currently active PML4 instance.",null,null],[3,"InactivePageTable","","An inactive page table that the CPU is not currently using",null,null],[5,"test_paging","","",null,{"inputs":[{"name":"a"}],"output":{"name":"mapresult"}}],[5,"kernel_remap","","Remaps the kernel using 4KiB pages.",null,{"inputs":[{"name":"initparams"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"activepml4"}}],[11,"deref_mut","","",1,{"inputs":[{"name":"self"}],"output":{"name":"activepml4"}}],[11,"new","","",1,{"inputs":[],"output":{"name":"activepagetable"}}],[11,"using","","Execute a closure with the recursive mapping temporarily changed to a new page table",1,{"inputs":[{"name":"self"},{"name":"inactivepagetable"},{"name":"temppage"},{"name":"f"}],"output":{"name":"mapresult"}}],[11,"replace_with","","Replace the current `ActivePageTable` with the given `InactivePageTable`",1,{"inputs":[{"name":"self"},{"name":"inactivepagetable"}],"output":{"name":"inactivepagetable"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"translate","","",2,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"option"}}],[11,"translate_page","","",2,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"option"}}],[11,"map","","Modifies the page tables so that `page` maps to `frame`.",2,{"inputs":[{"name":"self"},{"name":"virtualpage"},{"name":"physicalpage"},{"name":"entryflags"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"identity_map","","",2,{"inputs":[{"name":"self"},{"name":"physicalpage"},{"name":"entryflags"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"map_to_any","","",2,{"inputs":[{"name":"self"},{"name":"virtualpage"},{"name":"entryflags"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"unmap","","Unmap the given `VirtualPage`.",2,{"inputs":[{"name":"self"},{"name":"virtualpage"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"new","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"is_mapped","","Returns true if the given page is mapped.",2,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",3,{"inputs":[{"name":"physicalpage"},{"name":"activepagetable"},{"name":"temppage"}],"output":{"name":"mapresult"}}],[0,"table","","",null,null],[3,"Table","paging::arch::table","A page table",null,null],[3,"EntryFlags","","",null,null],[3,"Entry","","",null,null],[4,"PML4Level","","",null,null],[4,"PDPTLevel","","",null,null],[4,"PDLevel","","",null,null],[4,"PTLevel","","",null,null],[17,"N_ENTRIES","","The number of entries in a page table.",null,null],[17,"PAGE_TABLE_SIZE","","Size of a page table (in bytes)",null,null],[17,"PML4_VADDR","","Base virtual address of the PML4 table",null,null],[17,"PML4_PTR","","A pointer to the PML4 table",null,null],[17,"ENTRY_FLAGS_MASK","","Mask to apply to a page table entry to isolate the flags",null,null],[17,"PRESENT","","Present flag. Must be 1 to map a 2-MByte page or reference a page table.",null,null],[17,"WRITABLE","","Writable flag. If 0, writes may not be allowed to the 2-MB region controlled by this entry",null,null],[17,"USER_ACCESSIBLE","","",null,null],[17,"WRITE_THROUGH","","",null,null],[17,"NO_CACHE","","",null,null],[17,"ACCESSED","","",null,null],[17,"DIRTY","","",null,null],[17,"HUGE_PAGE","","",null,null],[17,"GLOBAL","","",null,null],[17,"NO_EXECUTE","","",null,null],[8,"TableLevel","","",null,null],[18,"ADDR_SHIFT_AMOUNT","","How much to shift an address by to find its index in this table.",4,null],[18,"PAGE_SHIFT_AMOUNT","","How much to shift a page number by to find its index in this level table",4,null],[18,"INDEX_MASK","","Mask for indices",4,null],[8,"IndexOf","","",null,null],[10,"index_of","","",5,{"inputs":[{"name":"i"}],"output":{"name":"usize"}}],[8,"Sublevel","","",null,null],[16,"Next","","",6,null],[0,"tlb","paging::arch","",null,null],[5,"flush_all","paging::arch::tlb","Invalidate the TLB completely by reloading the CR3 register.",null,{"inputs":[],"output":null}],[8,"Flush","","Something which may be flushed from the TLB",null,null],[10,"invlpg","","Invalidate this object in the TLB using the `invlpg` instruction.",7,{"inputs":[{"name":"self"}],"output":null}],[0,"temp","paging::arch","",null,null],[3,"TempPage","paging::arch::temp","",null,null],[3,"FrameCache","","",null,null],[0,"cr3","paging::arch","",null,null],[5,"current_pml4","paging::arch::cr3","Returns the current Page Meta-Level 4 table",null,null],[5,"set_pml4","","Sets the current Page Meta-Level 4 Table",null,{"inputs":[{"name":"table"}],"output":null}],[0,"stack","paging","Stack allocator",null,null],[6,"Stack","paging::stack","",null,null],[8,"StackAllocator","","",null,null],[10,"allocate","","",8,{"inputs":[{"name":"self"},{"name":"activepagetable"},{"name":"a"},{"name":"usize"}],"output":{"name":"allocresult"}}],[6,"MapResult","paging","",null,null],[8,"Mapper","","",null,null],[16,"Flags","","",9,null],[10,"translate","","Translates a virtual address to the corresponding physical address.",9,{"inputs":[{"name":"self"},{"name":"vaddr"}],"output":{"name":"option"}}],[10,"translate_page","","Translates a virtual page to a physical frame.",9,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"option"}}],[10,"map","","Modifies the page tables so that `page` maps to `frame`.",9,null],[10,"identity_map","","Identity map a given `frame`.",9,null],[10,"map_to_any","","Map the given `VirtualPage` to any free frame.",9,null],[10,"unmap","","Unmap the given `VirtualPage`.",9,{"inputs":[{"name":"self"},{"name":"virtualpage"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"maperr"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[18,"ADDR_SHIFT_AMOUNT","paging::arch::table","How much to shift an address by to find its index in this table.",4,null],[18,"PAGE_SHIFT_AMOUNT","","How much to shift a page number by to find its index in this level table",4,null],[18,"INDEX_MASK","","Mask for indices",4,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"page_table_for","","",10,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"option"}}],[11,"page_table_mut_for","","",10,{"inputs":[{"name":"self"},{"name":"virtualpage"}],"output":{"name":"option"}}],[11,"index","","",10,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"entry"}}],[11,"index_mut","","",10,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"entry"}}],[11,"zero","","Zeroes out the page table by setting all entries \"unused\"",10,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"start_paddr","","Return the start physical address of this `Table`",10,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"frame","","Return the `PhysicalPage` containing this table.",10,{"inputs":[{"name":"self"}],"output":{"name":"physicalpage"}}],[11,"next_table","","Returns the next table, or `None` if none exists",10,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"next_table_mut","","Mutably borrows the next table.",10,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"create_next","","Returns the next table, creating it if it does not exist.",10,{"inputs":[{"name":"self"},{"name":"virtualpage"},{"name":"a"}],"output":{"name":"mapresult"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"entryflags"}}],[11,"partial_cmp","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"option"}}],[11,"lt","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"le","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"gt","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"ge","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"cmp","","",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"ordering"}}],[11,"hash","","",11,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",11,{"inputs":[],"output":{"name":"entryflags"}}],[11,"all","","Returns the set containing all flags.",11,{"inputs":[],"output":{"name":"entryflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",11,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",11,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",11,{"inputs":[{"name":"u64"}],"output":{"name":"entryflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"entryflags"}}],[11,"bitor_assign","","Adds the set of flags.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"entryflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"entryflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":{"name":"entryflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",11,{"inputs":[{"name":"self"},{"name":"entryflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",11,{"inputs":[{"name":"self"}],"output":{"name":"entryflags"}}],[11,"extend","","",11,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",11,{"inputs":[{"name":"t"}],"output":{"name":"entryflags"}}],[11,"is_huge","","Returns true if this page is huge",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_present","","Returns true if this page is present",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_present","","",11,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"self"}}],[11,"set_writable","","",11,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"self"}}],[11,"set_executable","","",11,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"self"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",12,{"inputs":[{"name":"paddr"}],"output":{"name":"self"}}],[11,"do_huge","","",12,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"is_unused","","Returns true if this is an unused entry",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_unused","","Sets this entry to be unused",12,{"inputs":[{"name":"self"}],"output":null}],[11,"is_huge","","Returns true if this page is huge",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"flags","","Access the entry's bitflags.",12,{"inputs":[{"name":"self"}],"output":{"name":"entryflags"}}],[11,"get_addr","","Returns the physical address pointed to by this page table entry",12,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"get_frame","","Returns the frame in memory pointed to by this page table entry.",12,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"set","","",12,{"inputs":[{"name":"self"},{"name":"physicalpage"},{"name":"entryflags"}],"output":null}],[11,"from","","",11,{"inputs":[{"name":"section"}],"output":{"name":"self"}}],[11,"fmt","paging::arch::temp","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref","","",13,{"inputs":[{"name":"self"}],"output":{"name":"virtualpage"}}],[11,"deref_mut","","",13,{"inputs":[{"name":"self"}],"output":{"name":"virtualpage"}}],[11,"new","","Create a new `TempPage`.",13,{"inputs":[{"name":"usize"},{"name":"a"}],"output":{"name":"self"}}],[11,"map_to","","Map the `TempPage` to the given frame in the `ActivePageTable`.",13,{"inputs":[{"name":"self"},{"name":"physicalpage"},{"name":"activepagetable"}],"output":{"name":"mapresult"}}],[11,"map_to_table","","",13,{"inputs":[{"name":"self"},{"name":"physicalpage"},{"name":"activepagetable"}],"output":{"name":"mapresult"}}],[11,"unmap","","",13,{"inputs":[{"name":"self"},{"name":"activepagetable"}],"output":{"name":"mapresult"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",14,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"allocate","","",14,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[11,"deallocate","","",14,{"inputs":[{"name":"self"},{"name":"physicalpage"}],"output":null}],[11,"allocate_range","","",14,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[11,"deallocate_range","","",14,{"inputs":[{"name":"self"},{"name":"framerange"}],"output":null}]],"paths":[[4,"MapErr"],[3,"ActivePageTable"],[3,"ActivePML4"],[3,"InactivePageTable"],[8,"TableLevel"],[8,"IndexOf"],[8,"Sublevel"],[8,"Flush"],[8,"StackAllocator"],[8,"Mapper"],[3,"Table"],[3,"EntryFlags"],[3,"Entry"],[3,"TempPage"],[3,"FrameCache"]]};
searchIndex["params"] = {"doc":"SOS init parameters","items":[[3,"InitParams","params","Parameters used during the init process",null,null],[12,"kernel_base","","The base of the kernel memory range",0,null],[12,"kernel_top","","The top of the kernel memory range",0,null],[12,"heap_base","","The base of the memory range for the kernel heap",0,null],[12,"heap_top","","The top of the memory range to use for the kernel heap",0,null],[12,"stack_base","","The base of the memory range for the kernel stack",0,null],[12,"stack_top","","The top of the memory range to use for the kernel stack",0,null],[12,"multiboot_start","","The start address of the Multiboot info structure, if it exists.",0,null],[12,"multiboot_end","","The end address of the Multiboot info structure, if it exists.",0,null],[12,"mem_map","","Map of memory areas",0,null],[12,"elf_sections","","Map of elf sections",0,null],[0,"mem","","Memory parameters",null,null],[3,"Area","params::mem","A memory area",null,null],[12,"start_addr","","The start address of this memory area",1,null],[12,"end_addr","","The end address of this memory area",1,null],[12,"is_usable","","Whether or not the memory area is usable",1,null],[6,"Map","","A memory map is an iterator over memory areas",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"area"}}],[6,"ElfSections","params","If we are on x86_64 or armv7 this uses the 64-bit ELF word",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"initparams"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"elf_sections","","Returns an iterator over the kernel's ELF sections",0,{"inputs":[{"name":"self"}],"output":{"name":"elfsections"}}],[11,"multiboot_start","","Returns the start address of the multiboot info struct",0,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"multiboot_end","","Returns the end address of the multiboot info struct",0,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"kernel_frames","","Returns the range of frames containing the kernel binary.",0,{"inputs":[{"name":"self"}],"output":{"name":"framerange"}}],[11,"heap_frames","","Returns the range of frames containing the kernel heap",0,{"inputs":[{"name":"self"}],"output":{"name":"framerange"}}],[11,"stack_frames","","Returns the range of frames containing the kernel stack.",0,{"inputs":[{"name":"self"}],"output":{"name":"framerange"}}],[11,"mem_map","","returns an iterator over the memory map",0,{"inputs":[{"name":"self"}],"output":{"name":"map"}}]],"paths":[[3,"InitParams"],[3,"Area"]]};
searchIndex["rlibc"] = {"doc":"A bare-metal library supplying functions rustc may lower code to","items":[[5,"memcpy","rlibc","",null,null],[5,"memmove","","",null,null],[5,"memset","","",null,null],[5,"memcmp","","",null,null]],"paths":[]};
searchIndex["sos_alloc"] = {"doc":"SOS memory allocation library","items":[[3,"Excess","sos_alloc","Represents the combination of a starting address and a total capacity of the returned block.",null,null],[3,"Layout","","Category for a memory record.",null,null],[3,"CannotReallocInPlace","","The `CannotReallocInPlace` error is used when `fn realloc_in_place` was unable to reuse the given memory block for a requested layout.",null,null],[4,"AllocErr","","The `AllocErr` error specifies whether an allocation failure is specifically due to resource exhaustion or if it is due to something wrong when combining the given input arguments with this allocator.",null,null],[13,"Exhausted","","Error due to hitting some resource limit or otherwise running out of memory. This condition strongly implies that some series of deallocations would allow a subsequent reissuing of the original allocation request to succeed.",0,null],[12,"request","sos_alloc::AllocErr","",0,null],[13,"Unsupported","sos_alloc","Error due to allocator being fundamentally incapable of satisfying the original request. This condition implies that such an allocation request will never succeed on the given allocator, regardless of environment, memory pressure, or other contextual condtions.",0,null],[12,"details","sos_alloc::AllocErr","",0,null],[0,"frame","sos_alloc","Frame allocation",null,null],[3,"BorrowedFrame","sos_alloc::frame","A borrowed handle on a frame with a specified lifetime.",null,null],[3,"BorrowedFrameRange","","Identical to a `BorrowedFrame` but borrowing a range of `Frame`s.",null,null],[0,"mem_map","","A simple allocator using the [`InitParams`] memory map.",null,null],[3,"MemMapAllocator","sos_alloc::frame::mem_map","A simple area allocator.",null,null],[11,"from","","",1,{"inputs":[{"name":"initparams"}],"output":{"name":"self"}}],[11,"allocate","","",1,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[11,"deallocate","","Deallocate a frame",1,{"inputs":[{"name":"self"},{"name":"frame"}],"output":null}],[11,"allocate_range","","Allocate a range of frames",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[11,"deallocate_range","","Deallocate a range of frames",1,{"inputs":[{"name":"self"},{"name":"framerange"}],"output":null}],[8,"Allocator","sos_alloc::frame","An allocator for allocating physical frames.",null,null],[10,"allocate","","Allocate a new frame",2,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[10,"deallocate","","Deallocate a frame",2,{"inputs":[{"name":"self"},{"name":"frame"}],"output":null}],[10,"allocate_range","","Allocate a range of frames",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[10,"deallocate_range","","Deallocate a range of frames",2,{"inputs":[{"name":"self"},{"name":"framerange"}],"output":null}],[8,"Lender","","An allocator capable of lending [borrowed frame]s",null,null],[10,"borrow","","Borrow a `Frame` from this allocator. e  The `BorrowedFrame` will live as long as this allocator, and will  contain a handle on a `Frame` that will be automatically deallocated  when the `BorrowedFrame` is dropped.",3,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[10,"borrow_range","","Borrow a `FrameRange` from this allocator.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"allocresult"}}],[11,"deref","","",4,null],[11,"deref_mut","","",4,null],[11,"drop","","",4,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",5,null],[11,"deref_mut","","",5,null],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[0,"borrow","sos_alloc","",null,null],[3,"BorrowedPtr","sos_alloc::borrow","A borrowed handle on a heap allocation with a specified lifetime.",null,null],[3,"Borrowed","","A borrowed handle on a heap allocation with a specified lifetime.",null,null],[8,"Lender","","",null,null],[16,"Borrowed","","",6,null],[10,"borrow","","",6,null],[11,"new","","",7,{"inputs":[{"name":"address"},{"name":"layout"},{"name":"mutex"}],"output":{"name":"self"}}],[11,"deref","","",7,null],[11,"drop","","",7,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",8,{"inputs":[{"name":"unique"},{"name":"mutex"}],"output":{"name":"self"}}],[11,"deref","","",8,null],[11,"deref_mut","","",8,null],[11,"drop","","",8,{"inputs":[{"name":"self"}],"output":null}],[0,"buddy","sos_alloc","Simple buddy-block allocator",null,null],[3,"FreeBlock","sos_alloc::buddy","A free block header stores a pointer to the next and previous free blocks.",null,null],[3,"Heap","","Structure with data for implementing the buddy block allocation strategy.",null,null],[12,"start_addr","","Address of the base of the heap. This must be aligned on a `MIN_ALIGN` boundary.",9,null],[12,"heap_size","","Number of blocks in the heap (must be a power of 2)",9,null],[12,"min_block_size","","Minimum block size",9,null],[0,"system","","This module integrates the buddy heap allocator into the Rust runtime.",null,null],[3,"BuddyFrameAllocator","sos_alloc::buddy::system","A frame allocator using the system's buddy-block heap allocator",null,null],[5,"init_heap","","Initialize the system heap at the given start address",null,null],[5,"__rust_allocate","","",null,null],[5,"__rust_deallocate","","",null,null],[5,"__rust_reallocate","","",null,null],[5,"__rust_reallocate_inplace","","This is currently unsupported, so we just silently ignore it and return the old size.",null,null],[5,"__rust_usable_size","","",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[17,"NUM_FREE_LISTS","","The number of free lists for the kernel heap",null,null],[11,"new","","Construct a new `BuddyFrameAllocator`",10,{"inputs":[],"output":{"name":"self"}}],[6,"FreeList","sos_alloc::buddy","A `FreeList` is a list of unique free blocks",null,null],[11,"prev","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"next","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"prev_mut","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"next_mut","","",11,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"new","","Construct a new `Heap`.",9,null],[11,"add_block","","Add a block of max order",9,{"inputs":[{"name":"self"},{"name":"address"}],"output":null}],[11,"alloc_size","","Computes the size of an allocation request.",9,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"alloc_order","","Computes the order of an allocation request.",9,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"get_buddy","","Finds the buddy block for a given block.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"address"}],"output":{"name":"option"}}],[11,"remove_block","","Finds and removes the target block from the free list.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"address"}],"output":{"name":"bool"}}],[11,"alloc","","Returns a pointer suitable for holding data described by `layout`, meeting its size and alignment guarantees.",9,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"dealloc","","Release an allocated block of memory.",9,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[0,"bump_ptr","sos_alloc","",null,null],[3,"BumpPtr","sos_alloc::bump_ptr","A simple bump pointer allocator.",null,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",12,{"inputs":[{"name":"paddr"},{"name":"paddr"}],"output":{"name":"self"}}],[11,"alloc","","",12,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"dealloc","","",12,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[0,"system","sos_alloc","",null,null],[3,"SystemAllocator","sos_alloc::system","",null,null],[4,"Tier","","",null,null],[13,"Uninitialized","","",13,null],[13,"Bump","","",13,null],[13,"Buddy","","",13,null],[11,"deref","","",13,null],[11,"alloc","","",13,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"allocresult"}}],[11,"dealloc","","",13,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[11,"borrow_ptr","","Borrow a raw allocation from the system allocator",14,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"allocresult"}}],[11,"borrow","","Borrow an object allocation from the system allocator.",14,{"inputs":[{"name":"self"}],"output":{"name":"allocresult"}}],[6,"AllocResult","sos_alloc","",null,null],[6,"Size","","",null,null],[6,"Capacity","","",null,null],[6,"Alignment","","",null,null],[6,"Address","","",null,null],[8,"Allocator","","An implementation of `Allocator` can allocate, reallocate, and deallocate arbitrary blocks of data described via `Layout`.",null,null],[10,"alloc","","Returns a pointer suitable for holding data described by `layout`, meeting its size and alignment guarantees.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[10,"dealloc","","Deallocate the memory referenced by `ptr`.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"}],"output":null}],[11,"oom","","Allocator-specific method for signalling an out-of-memory condition.",15,null],[11,"usable_size","","Returns bounds on the guaranteed usable size of a successful allocation created with the specified `layout`.",15,null],[11,"realloc","","Returns a pointer suitable for holding data described by `new_layout`, meeting its size and alignment guarantees. To accomplish this, this may extend or shrink the allocation referenced by `ptr` to fit `new_layout`.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"result"}}],[11,"alloc_excess","","Behaves like `fn alloc`, but also returns the whole size of the returned block. For some `layout` inputs, like arrays, this may include extra storage usable for additional data.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"result"}}],[11,"realloc_excess","","Behaves like `fn realloc`, but also returns the whole size of the returned block. For some `layout` inputs, like arrays, this may include extra storage usable for additional data.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"result"}}],[11,"realloc_in_place","","Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"result"}}],[11,"alloc_one","","Allocates a block suitable for holding an instance of `T`.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"dealloc_one","","Deallocates a block suitable for holding an instance of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"}],"output":null}],[11,"alloc_array","","Allocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"realloc_array","","Reallocates a block previously suitable for holding `n_old` instances of `T`, returning a block suitable for holding `n_new` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"dealloc_array","","Deallocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"}],"output":{"name":"result"}}],[11,"alloc_unchecked","","Returns a pointer suitable for holding data described by `layout`, meeting its size and alignment guarantees.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"option"}}],[11,"realloc_unchecked","","Returns a pointer suitable for holding data described by `new_layout`, meeting its size and alignment guarantees. To accomplish this, may extend or shrink the allocation referenced by `ptr` to fit `new_layout`. (In other words, ownership of the memory block associated with `ptr` is first transferred back to this allocator, but the same block may or may not be transferred back as the result of this call.)",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"option"}}],[11,"alloc_excess_unchecked","","Behaves like `fn alloc_unchecked`, but also returns the whole size of the returned block.",15,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"option"}}],[11,"realloc_excess_unchecked","","Behaves like `fn realloc_unchecked`, but also returns the whole size of the returned block.",15,{"inputs":[{"name":"self"},{"name":"address"},{"name":"layout"},{"name":"layout"}],"output":{"name":"option"}}],[11,"alloc_array_unchecked","","Allocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"realloc_array_unchecked","","Reallocates a block suitable for holding `n_old` instances of `T`, returning a block suitable for holding `n_new` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"dealloc_array_unchecked","","Deallocates a block suitable for holding `n` instances of `T`.",15,{"inputs":[{"name":"self"},{"name":"unique"},{"name":"usize"}],"output":null}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"layout"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"name":"bool"}}],[11,"from_size_align","","",16,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"layout"}}],[11,"size","","The minimum size in bytes for a memory block of this layout.",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"align","","The minimum byte alignment for a memory block of this layout.",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"new","","Constructs a `Layout` suitable for holding a value of type `T`.",16,{"inputs":[],"output":{"name":"self"}}],[11,"for_value","","Produces layout describing a record that could be used to allocate backing structure for `T` (which could be a trait or other unsized type like a slice).",16,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"align_to","","Creates a layout describing the record that can hold a value of the same layout as `self`, but that also is aligned to alignment `align` (measured in bytes).",16,{"inputs":[{"name":"self"},{"name":"alignment"}],"output":{"name":"self"}}],[11,"padding_needed_for","","Returns the amount of padding we must insert after `self` to ensure that the following address will satisfy `align` (measured in bytes).",16,{"inputs":[{"name":"self"},{"name":"alignment"}],"output":{"name":"usize"}}],[11,"repeat","","Creates a layout describing the record for `n` instances of `self`, with a suitable amount of padding between each to ensure that each instance is given its requested size and alignment. On success, returns `(k, offs)` where `k` is the layout of the array and `offs` is the distance between the start of each element in the array.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"extend","","Creates a layout describing the record for `self` followed by `next`, including any necessary padding to ensure that `next` will be properly aligned. Note that the result layout will satisfy the alignment properties of both `self` and `next`.",16,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"repeat_packed","","Creates a layout describing the record for `n` instances of `self`, with no padding between each instance.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"extend_packed","","Creates a layout describing the record for `self` followed by `next` with no additional padding between the two. Since no padding is inserted, the alignment of `next` is irrelevant, and is not incoporated at all into the resulting layout.",16,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"new_unchecked","","do indirectly validate, but that is not part of their specification.) Creates layout describing the record for a single instance of `T`.",16,{"inputs":[],"output":{"name":"self"}}],[11,"extend_unchecked","","Creates a layout describing the record for `self` followed by `next`, including any necessary padding to ensure that `next` will be properly aligned. Note that the result layout will satisfy the alignment properties of both `self` and `next`.",16,null],[11,"repeat_unchecked","","Creates a layout describing the record for `n` instances of `self`, with a suitable amount of padding between each.",16,null],[11,"repeat_packed_unchecked","","Creates a layout describing the record for `n` instances of `self`, with no padding between each instance.",16,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"extend_packed_unchecked","","Creates a layout describing the record for `self` followed by `next` with no additional padding between the two. Since no padding is inserted, the alignment of `next` is irrelevant, and is not incoporated at all into the resulting layout.",16,null],[11,"array","","Creates a layout describing the record for a `[T; n]`.",16,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"array_unchecked","","Creates a layout describing the record for a `[T; n]`.",16,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"allocerr"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"allocerr"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"allocerr"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"invalid_input","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"is_memory_exhausted","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_request_unsupported","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"cannotreallocinplace"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"cannotreallocinplace"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[4,"AllocErr"],[3,"MemMapAllocator"],[8,"Allocator"],[8,"Lender"],[3,"BorrowedFrame"],[3,"BorrowedFrameRange"],[8,"Lender"],[3,"BorrowedPtr"],[3,"Borrowed"],[3,"Heap"],[3,"BuddyFrameAllocator"],[3,"FreeBlock"],[3,"BumpPtr"],[4,"Tier"],[3,"SystemAllocator"],[8,"Allocator"],[3,"Layout"],[3,"CannotReallocInPlace"]]};
searchIndex["sos_intrusive"] = {"doc":"SOS Intrusive Collections","items":[[0,"rawlink","sos_intrusive","Implementation of the `RawLink` smart-ish pointer.",null,null],[3,"RawLink","sos_intrusive::rawlink","A `RawLink` provides an `Option`-like interface to a raw pointer.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"rawlink"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"rawlink"}],"output":{"name":"bool"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"none","","Equivalent of `Option::None` for a `RawLink`",0,{"inputs":[],"output":{"name":"rawlink"}}],[11,"some","","Equivalent of `Option::Some` for a `RawLink`",0,{"inputs":[{"name":"t"}],"output":{"name":"rawlink"}}],[11,"from_raw","","",0,null],[11,"resolve","","Resolve the `RawLink` to an `Option`",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"resolve_mut","","Resolve the `RawLink` to an `Option` on a mutable pointer",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_raw","","Please don't do this.",0,null],[11,"is_some","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_none","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"take","","Returns the `RawLink` and replaces it with `RawLink::none()`.",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"map","","",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"rawlink"}}],[0,"list","sos_intrusive","An intrusive linked list implementation using `RawLink`s.",null,null],[3,"List","sos_intrusive::list","The `List` struct is our way of interacting with an intrusive list.",null,null],[3,"ListCursorMut","","A cursor for an intrusive linked list.",null,null],[8,"OwnedRef","","",null,null],[10,"from_raw","","",1,null],[10,"take","","",1,{"inputs":[{"name":"self"}],"output":null}],[10,"get","","",1,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"get_mut","","",1,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"Node","","This trait defines a node in an intrusive list.",null,null],[10,"next","","",2,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[10,"prev","","",2,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[10,"next_mut","","",2,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[10,"prev_mut","","",2,{"inputs":[{"name":"self"}],"output":{"name":"rawlink"}}],[8,"Cursor","","",null,null],[16,"Item","","",3,null],[10,"next","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"prev","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"get","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"seek_forward","","",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[10,"seek_backward","","",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"new","","Construct a new `List<T, N>` with zero elements",4,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Returns the length of the list",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"front","","Borrows the first element of the list as an `Option`",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"back","","Borrows the last element of the list as an `Option`",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"front_mut","","Mutably borrows the first element of the list as an `Option`",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"back_mut","","Mutably borrows the last element of the list as an `Option`",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_empty","","Returns true if the list is empty.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push_front","","Push an element to the front of the list.",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"push_back","","Push an element to the back of the list.",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"pop_front","","Removes and returns the element at the front of the list.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"pop_back","","Removes and returns the element at the end of the list.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"peek_front","","Borrows the element at the front of the list",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"cursor_mut","","Returns a cursor for iterating over or modifying the list.",4,{"inputs":[{"name":"self"}],"output":{"name":"listcursormut"}}],[11,"from_iter","","",4,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","Advances the cursor to the next element and borrows it mutably.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"prev","","Steps back the cursor to the previous element and borrows it mutably.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"peek_next","","Borrows the next element in the list without advancing the cursor.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"peek_prev","","Borrows the previous element without stepping back the cursor.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remove","","Removes the element currently under the cursor and returns it.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"find_and_remove","","Searches for and removes the first element matching a predicate.",5,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"seek_forward","","Advances the cursor `n` elements and mutably borrows the final element.",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"seek_backward","","Moves the cursor back `n` times and mutably borrows the final element.",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}]],"paths":[[3,"RawLink"],[8,"OwnedRef"],[8,"Node"],[8,"Cursor"],[3,"List"],[3,"ListCursorMut"]]};
searchIndex["sos_kernel"] = {"doc":"SOS kernel This crate contains the kernel for SOS, the Stupid Operating System.","items":[[5,"kernel_main","sos_kernel","Kernel main loop",null,null],[5,"kernel_init","","Kernel initialization function called into by architecture-specific init",null,{"inputs":[{"name":"initparams"}],"output":null}],[0,"io","","Kernel IO.",null,null],[0,"term","sos_kernel::io","",null,null],[7,"CONSOLE","sos_kernel::io::term","The system's global VGA terminal TODO: should this live in the kernel instead?",null,null],[7,"__vga_buffer","","",null,null],[0,"keyboard","sos_kernel::io","PS/2 keyboard driver",null,null],[3,"Scancode","sos_kernel::io::keyboard","PS/2 keyboard scancode",null,null],[3,"Keyboard","","A PS/2 keyboard state",null,null],[12,"state","","The keyboard's modifier keys",0,null],[3,"Modifiers","","",null,null],[5,"read_char","","",null,{"inputs":[],"output":{"name":"option"}}],[17,"L_SHIFT","","",null,null],[17,"R_SHIFT","","",null,null],[17,"SHIFT","","",null,null],[17,"R_CTRL","","",null,null],[17,"L_CTRL","","",null,null],[17,"CTRL","","",null,null],[17,"R_ALT","","",null,null],[17,"L_ALT","","",null,null],[17,"ALT","","",null,null],[17,"CAPSLOCK","","",null,null],[17,"NUMLOCK","","",null,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"scancode"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"read_scancode","","",0,{"inputs":[{"name":"self"}],"output":{"name":"scancode"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"modifiers"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"ordering"}}],[11,"hash","","",2,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",2,{"inputs":[],"output":{"name":"modifiers"}}],[11,"all","","Returns the set containing all flags.",2,{"inputs":[],"output":{"name":"modifiers"}}],[11,"bits","","Returns the raw value of the flags currently stored.",2,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",2,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",2,{"inputs":[{"name":"u8"}],"output":{"name":"modifiers"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"modifiers"}}],[11,"bitor_assign","","Adds the set of flags.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"modifiers"}}],[11,"bitxor_assign","","Toggles the set of flags.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"modifiers"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":{"name":"modifiers"}}],[11,"sub_assign","","Disables all flags enabled in the set.",2,{"inputs":[{"name":"self"},{"name":"modifiers"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",2,{"inputs":[{"name":"self"}],"output":{"name":"modifiers"}}],[11,"extend","","",2,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",2,{"inputs":[{"name":"t"}],"output":{"name":"modifiers"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"is_shifted","","Returns true if either shift key is pressed.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_uppercase","","Returns true if the keyboard's state is currently uppercase.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"heap","sos_kernel","",null,null],[5,"initialize","sos_kernel::heap","Initialise the kernel heap.",null,{"inputs":[{"name":"initparams"}],"output":{"name":"result"}}],[0,"arch","sos_kernel","Architecture-specific implementation.",null,null],[5,"long_mode_init","sos_kernel::arch","Trampoline to ensure we have a correct stack frame for calling [`arch_init`]",null,{"inputs":[],"output":null}],[5,"arch_init","","Entry point for architecture-specific kernel init",null,{"inputs":[{"name":"paddr"}],"output":null}],[7,"HEAP_BASE","","",null,null],[7,"HEAP_TOP","","",null,null],[7,"STACK_BASE","","",null,null],[7,"STACK_TOP","","",null,null],[0,"drivers","","",null,null],[0,"serial","sos_kernel::arch::drivers","Serial port driver",null,null],[3,"Serial","sos_kernel::arch::drivers::serial","",null,null],[3,"COM1","","",null,null],[3,"COM2","","",null,null],[3,"COM3","","",null,null],[3,"COM4","","",null,null],[3,"SerialPort","","A serial port",null,null],[0,"vga","sos_kernel::arch::drivers","Arch-specific VGA port port driver",null,null],[5,"clear","sos_kernel::arch::drivers::vga","",null,{"inputs":[],"output":null}],[7,"CONSOLE","","The system's global VGA terminal",null,null],[0,"interrupts","sos_kernel::arch","",null,null],[5,"initialize","sos_kernel::arch::interrupts","Initialize interrupt handling.",null,{"inputs":[],"output":{"name":"result"}}],[5,"keyboard","","",null,{"inputs":[{"name":"interruptframe"}],"output":null}],[5,"breakpoint","","",null,{"inputs":[{"name":"interruptframe"}],"output":null}],[5,"empty_handler","","Empty dummy handler for undefined interrupts.",null,{"inputs":[{"name":"interruptframe"}],"output":null}],[0,"bda","sos_kernel::arch","BIOS Data Area",null,null],[0,"ports","sos_kernel::arch::bda","",null,null],[5,"com1","sos_kernel::arch::bda::ports","",null,{"inputs":[],"output":{"name":"option"}}],[5,"com2","","",null,{"inputs":[],"output":{"name":"option"}}],[5,"com3","","",null,{"inputs":[],"output":{"name":"option"}}],[5,"com4","","",null,{"inputs":[],"output":{"name":"option"}}],[5,"lpt1","","",null,{"inputs":[],"output":{"name":"option"}}],[5,"lpt2","","",null,{"inputs":[],"output":{"name":"option"}}],[5,"lpt3","","",null,{"inputs":[],"output":{"name":"option"}}],[0,"multiboot2","sos_kernel::arch","Code for reading & extracting data from Multiboot 2 boot information.",null,null],[3,"Header","sos_kernel::arch::multiboot2","",null,null],[12,"magic","","",3,null],[12,"arch","","",3,null],[12,"header_length","","",3,null],[12,"checksum","","",3,null],[12,"end_tag","","",3,null],[3,"Info","","",null,null],[12,"length","","",4,null],[3,"Tag","","A Multiboot tag.",null,null],[12,"ty","","the type of this tag.",5,null],[3,"Tags","","An iterator over Multiboot 2 tags.",null,null],[3,"MemMapTag","","A Memory Map tag",null,null],[12,"entry_size","","",6,null],[12,"entry_version","","",6,null],[3,"CommandLineTag","","A tag that stores the boot command line.",null,null],[12,"command_line","","The boot command line.",7,null],[3,"ModulesTag","","",null,null],[12,"mod_begin","","The address at which the module begins.",8,null],[12,"mod_end","","The address at which the module ends.",8,null],[12,"string","","A string (typically a command line)",8,null],[3,"MemArea","","A multiboot 2 memory area",null,null],[12,"base","","the starting address of the memory area",9,null],[12,"length","","the length of the memory area",9,null],[12,"ty","","the type of the memory area",9,null],[3,"MemAreas","","An iterator over memory areas",null,null],[3,"ElfSectionsTag","","A Multiboot 2 ELF sections tag",null,null],[12,"n_sections","","the number of sections pointed to by this tag",10,null],[12,"section_size","","the size of each ELF section",10,null],[4,"HeaderArch","","",null,null],[13,"I386","","",11,null],[13,"Mips","","",11,null],[4,"TagType","","Types of Multiboot tags",null,null],[13,"End","","Tag that indicates the end of multiboot tags",12,null],[13,"CommandLine","","Command line passed to the bootloader",12,null],[13,"BootloaderName","","",12,null],[13,"Modules","","",12,null],[13,"BasicMemInfo","","",12,null],[13,"BIOSBootDev","","",12,null],[13,"MemoryMap","","",12,null],[13,"VBEInfo","","",12,null],[13,"FramebufferInfo","","",12,null],[13,"ELFSections","","",12,null],[13,"APMTable","","",12,null],[4,"MemAreaType","","",null,null],[13,"Available","","",13,null],[13,"Acpi","","",13,null],[13,"Preserve","","",13,null],[6,"Word","","",null,null],[7,"HEADER","","",null,null],[17,"MAGIC","","",null,null],[17,"ARCH_BITS","sos_kernel::arch","",null,null],[0,"logger","sos_kernel","",null,null],[5,"initialize","sos_kernel::logger","",null,{"inputs":[],"output":{"name":"result"}}],[5,"shutdown","","",null,{"inputs":[],"output":{"name":"result"}}],[17,"VERSION_STRING","sos_kernel","SOS version number",null,null],[11,"write_str","sos_kernel::arch::drivers::serial","",14,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"deref","","",15,{"inputs":[{"name":"self"}],"output":{"name":"mutex"}}],[11,"initialize","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",16,{"inputs":[{"name":"self"}],"output":{"name":"mutex"}}],[11,"initialize","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",17,{"inputs":[{"name":"self"}],"output":{"name":"mutex"}}],[11,"initialize","","",17,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",18,{"inputs":[{"name":"self"}],"output":{"name":"mutex"}}],[11,"initialize","","",18,{"inputs":[{"name":"self"}],"output":null}],[11,"has_byte","","Returns true if the serial port has recieved data",19,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","","",19,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"read_byte","","",19,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"write_byte","","",19,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"read","","Reads a single byte into the given buffer",19,null],[11,"read_all","","Reads a new byte into each position in the buffer.",19,null],[11,"write","","",19,null],[11,"write_str","","",19,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"start_addr","sos_kernel::arch::multiboot2","",4,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"end_addr","","",4,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"from","","TODO: rewrite this as a `TryFrom` implementation (see issue #85)",4,{"inputs":[{"name":"paddr"}],"output":{"name":"result"}}],[11,"get_tag","","Finds the tag with the given tag type.",4,{"inputs":[{"name":"self"},{"name":"tagtype"}],"output":{"name":"option"}}],[11,"mem_map","","Finds the memory map tag.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"elf_sections","","Finds the ELF sections tag.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"kernel_frames","","Returns the kernel frame range from the Multiboot 2 ELF Sections",4,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"tagtype"}],"output":{"name":"bool"}}],[11,"next","","",20,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"areas","","Returns an iterator over all the memory areas in this tag.",6,{"inputs":[{"name":"self"}],"output":{"name":"memareas"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"memareatype"}],"output":{"name":"bool"}}],[11,"cmp","","",13,{"inputs":[{"name":"self"},{"name":"memareatype"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",13,{"inputs":[{"name":"self"},{"name":"memareatype"}],"output":{"name":"option"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"address","","",9,{"inputs":[{"name":"self"}],"output":{"name":"paddr"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"memareas"}}],[11,"next","","",21,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"sections","","Returns an iterator over the ELF sections pointed to by this tag.",10,{"inputs":[{"name":"self"}],"output":{"name":"sections"}}]],"paths":[[3,"Keyboard"],[3,"Scancode"],[3,"Modifiers"],[3,"Header"],[3,"Info"],[3,"Tag"],[3,"MemMapTag"],[3,"CommandLineTag"],[3,"ModulesTag"],[3,"MemArea"],[3,"ElfSectionsTag"],[4,"HeaderArch"],[4,"TagType"],[4,"MemAreaType"],[3,"Serial"],[3,"COM1"],[3,"COM2"],[3,"COM3"],[3,"COM4"],[3,"SerialPort"],[3,"Tags"],[3,"MemAreas"]]};
searchIndex["spin"] = {"doc":"Synchronization primitives based on spinning","items":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",null,null],[3,"MutexGuard","","A guard to which the protected data can be accessed",null,null],[3,"RwLock","","A reader-writer lock",null,null],[3,"RwLockReadGuard","","A guard to which the protected data can be read",null,null],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",null,null],[11,"new","","Creates a new spinlock wrapping the supplied data.",0,{"inputs":[{"name":"t"}],"output":{"name":"mutex"}}],[11,"lock","","Locks the spinlock and returns a guard.",0,{"inputs":[{"name":"self"}],"output":{"name":"mutexguard"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"mutex"}}],[11,"deref","","",1,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",1,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","The dropping of the MutexGuard will release the lock it was created from.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Creates a new spinlock wrapping the supplied data.",2,{"inputs":[{"name":"t"}],"output":{"name":"rwlock"}}],[11,"read","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",2,{"inputs":[{"name":"self"}],"output":{"name":"rwlockreadguard"}}],[11,"try_read","","Attempt to acquire this lock with shared read access.",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"write","","Lock this rwlock with exclusive write access, blocking the current thread until it can be acquired.",2,{"inputs":[{"name":"self"}],"output":{"name":"rwlockwriteguard"}}],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"rwlock"}}],[11,"deref","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref","","",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"drop","","",4,{"inputs":[{"name":"self"}],"output":null}]],"paths":[[3,"Mutex"],[3,"MutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"]]};
searchIndex["util"] = {"doc":"General purpose stuff I couldn't find a better home for.","items":[[4,"Void","util","The unreachable Void type.",null,null],[0,"io","","",null,null],[8,"Read","util::io","The `Read` trait allows for reading bytes from a source.",null,null],[16,"Error","","",0,null],[10,"read","","Pull some bytes from this source into the specified buffer, returning how many bytes were read.",0,null],[10,"read_all","","Read all bytes until EOF in this source, placing them into `buf`.",0,null],[8,"Write","","A trait for objects which are byte-oriented sinks.",null,null],[16,"Error","","",1,null],[10,"write","","Write a buffer into this object, returning how many bytes were written.",1,null],[0,"macros","util","",null,null],[0,"newtype_impl","util::macros","",null,null],[8,"Align","util","",null,null],[11,"align_up","","",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"align_down","","",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[14,"expr","","",null,null],[14,"forward_ref_binop","","",null,null],[14,"impl_ops","","",null,null],[14,"impl_assign_ops","","",null,null],[14,"impl_fmt","","",null,null]],"paths":[[8,"Read"],[8,"Write"],[8,"Align"],[4,"Void"]]};
searchIndex["vga"] = {"doc":"SOS VGA Code for interacting with the system's VGA buffer.","items":[[3,"Palette","vga","",null,null],[3,"Char","","A colored VGA character.",null,null],[12,"ascii","","",0,null],[12,"colors","","",0,null],[3,"Terminal","","",null,null],[4,"Color","","VGA color codes",null,null],[13,"Black","","",1,null],[13,"Blue","","",1,null],[13,"Green","","",1,null],[13,"Cyan","","",1,null],[13,"Red","","",1,null],[13,"Magenta","","",1,null],[13,"Brown","","",1,null],[13,"LightGrey","","",1,null],[13,"DarkGrey","","",1,null],[13,"LightBlue","","",1,null],[13,"LightGreen","","",1,null],[13,"LightCyan","","",1,null],[13,"LightRed","","",1,null],[13,"LightMagenta","","",1,null],[13,"Yellow","","",1,null],[13,"White","","",1,null],[0,"panic","","Panic handling.",null,null],[5,"rust_begin_unwind","vga::panic","Called to handle a panic.",null,null],[0,"kinfo","vga","Macros for kernel-level logging",null,null],[0,"status","","",null,null],[8,"Status","vga::status","",null,null],[10,"okay","","",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"fail","","",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"okay","vga","",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fail","","",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[6,"Buffer","","The type signature fot the actual VGA buffer",null,null],[7,"CONSOLE","","The system's global VGA terminal TODO: should this live in the kernel instead?",null,null],[17,"X_MAX","","",null,null],[17,"Y_MAX","","",null,null],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"option"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"bool"}}],[11,"cmp","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"option"}}],[11,"lt","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"bool"}}],[11,"le","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"bool"}}],[11,"gt","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"bool"}}],[11,"ge","","",4,{"inputs":[{"name":"self"},{"name":"palette"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"palette"}}],[11,"new","","Returns a `Palette` with the given foreground and background color.",4,{"inputs":[{"name":"color"},{"name":"color"}],"output":{"name":"self"}}],[11,"set_foreground","","Returns a new `Palette` with this palette's background color, and the specified foreground color.",4,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"self"}}],[11,"set_background","","Returns a new `Palette` with this palette's foreground color, and the specified background color.",4,{"inputs":[{"name":"self"},{"name":"color"}],"output":{"name":"self"}}],[11,"foreground","","Returns this `Palette`'s foreground color.",4,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"background","","Returns this `Palette`'s background color.",4,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"char"}}],[11,"empty","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"x_position","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"new","","Constructs a new `Terminal` for abuffer starting at the given address.",3,{"inputs":[{"name":"palette"},{"name":"usize"}],"output":{"name":"terminal"}}],[11,"set_colors","","Set the color palette used for writing subsequent characters.",3,{"inputs":[{"name":"self"},{"name":"color"},{"name":"color"}],"output":{"name":"self"}}],[11,"clear","","Clear the terminal",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"write_byte","","Write the given byte to the terminal, and advance the cursor position.",3,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"self"}}],[11,"write_str","","",3,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[14,"println","","Macro for printing to the standard output.",null,null],[14,"print","","Macro for printing to the standard output.",null,null],[14,"attempt","","",null,null],[14,"kinfo","","",null,null],[14,"kinfoln","","",null,null]],"paths":[[3,"Char"],[4,"Color"],[8,"Status"],[3,"Terminal"],[3,"Palette"]]};
initSearch(searchIndex);
